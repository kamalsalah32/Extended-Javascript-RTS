
> mermaid-monorepo@10.2.4 ci /Users/kamalsalah/Desktop/Thesis/finalEvaluation/evaluation/mermaid
> vitest run


 RUN  v1.6.0 /Users/kamalsalah/Desktop/Thesis/finalEvaluation/evaluation/mermaid

 ✓ packages/mermaid/src/diagrams/class/classTypes.spec.ts  (93 tests) 24ms
 ✓ packages/mermaid/src/diagrams/git/gitGraphRenderer.ts  (30 tests) 10ms
 ✓ packages/mermaid/src/diagrams/er/parser/erDiagram.spec.js  (596 tests | 1 skipped) 137ms
stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing basic gitGraph > should handle a gitGraph definition
Ambiguous Alternatives Detected: <0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, commit, NEWLINE> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing basic gitGraph > should checkout a branch
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, branch, ID> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing more advanced gitGraphs > should throw error when trying to merge, when current branch has no commits
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, merge, ID> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing more advanced gitGraphs > accessibility > should handle a title and a description (accDescr)
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, ACC_TITLE, NEWLINE> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

 ✓ packages/mermaid/src/diagrams/git/gitGraph.spec.ts  (68 tests | 4 skipped) 136ms
 ✓ packages/mermaid/src/diagrams/class/classDiagram.spec.ts  (367 tests | 1 skipped) 540ms
 ✓ packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.spec.js  (29 tests) 15ms
 ✓ packages/mermaid/src/diagrams/sequence/sequenceDiagram.spec.js  (101 tests) 407ms
 ✓ packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts  (43 tests | 1 skipped) 16ms
 ✓ packages/mermaid/src/diagrams/xychart/parser/xychart.jison.spec.ts  (48 tests) 18ms
 ✓ packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison.spec.ts  (14 tests) 20ms
 ✓ packages/mermaid/src/utils.spec.ts  (53 tests) 18ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-1 should handle a simple root definition abc122
33.042 : INFO :  Node:  root
33.042 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-2 should handle a hierachial kanban definition
33.045 : INFO :  Node:  root
33.045 : TRACE :  Stop NL 
33.045 : INFO :  Node:  child1
33.045 : TRACE :  Stop NL 
33.045 : INFO :  Node:  child2
33.045 : TRACE :  Stop NL 
33.045 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > 3 should handle a simple root definition with a shape and without an id abc123
33.049 : TRACE :  Long description: root
33.049 : TRACE :  node end )
33.049 : TRACE :  node found .. (
33.049 : DEBUG :  In get type ( )
33.049 : INFO :  Node:  root
33.049 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-4 should not dsitinguis between deeper hierachial levels in thr kanban definition
33.049 : INFO :  Node:  root
33.049 : TRACE :  Stop NL 
33.049 : INFO :  Node:  child1
33.049 : TRACE :  Stop NL 
33.049 : INFO :  Node:  leaf1
33.049 : TRACE :  Stop NL 
33.049 : INFO :  Node:  child2
33.049 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > 5 Multiple sections are ok
33.050 : INFO :  Node:  section1
33.050 : TRACE :  Stop NL 
33.050 : INFO :  Node:  section2
33.050 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-6 real root in wrong place
33.051 : INFO :  Node:  root
33.051 : TRACE :  Stop NL 
33.051 : INFO :  Node:  fakeRoot
33.051 : TRACE :  Stop NL 
33.051 : INFO :  Node:  realRootWrongPlace

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-7 should handle an id and type for a node definition
33.052 : TRACE :  Long description: The root
33.052 : TRACE :  node end ... ]
33.052 : TRACE :  node found .. root
33.052 : DEBUG :  In get type [ ]
33.052 : INFO :  Node:  root
33.052 : TRACE :  Stop NL 
33.052 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-8 should handle an id and type for a node definition
33.053 : INFO :  Node:  root
33.053 : TRACE :  Stop NL 
33.053 : TRACE :  Long description: child1
33.053 : TRACE :  node end )
33.053 : TRACE :  node found .. theId
33.053 : DEBUG :  In get type ( )
33.053 : INFO :  Node:  theId
33.053 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-9 should handle an id and type for a node definition
33.053 : TRACE :  Node:  root
33.053 : TRACE :  Stop NL 
33.053 : TRACE :  Long description: child1
33.053 : TRACE :  node end )
33.053 : TRACE :  node found .. theId
33.053 : DEBUG :  In get type ( )
33.053 : INFO :  Node:  theId
33.053 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-13 should be possible to set an icon for the node
33.054 : TRACE :  Long description: The root
33.054 : TRACE :  node end ... ]
33.054 : TRACE :  node found .. root
33.054 : DEBUG :  In get type [ ]
33.054 : INFO :  Node:  root
33.054 : TRACE :  Stop NL 
33.054 : TRACE :  Begin icon
33.054 : TRACE :  end icon
33.054 : TRACE :  Icon:  bomb
33.054 : TRACE :  Stop NL 
33.054 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-14 should be possible to set classes for the node
33.055 : TRACE :  Long description: The root
33.055 : TRACE :  node end ... ]
33.055 : TRACE :  node found .. root
33.055 : DEBUG :  In get type [ ]
33.055 : INFO :  Node:  root
33.055 : TRACE :  Stop NL 
33.055 : TRACE :  Stop NL 
33.055 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-15 should be possible to set both classes and icon for the node
33.060 : TRACE :  Long description: The root
33.060 : TRACE :  node end ... ]
33.060 : TRACE :  node found .. root
33.060 : DEBUG :  In get type [ ]
33.060 : INFO :  Node:  root
33.060 : TRACE :  Stop NL 
33.060 : TRACE :  Stop NL 
33.060 : TRACE :  Begin icon
33.060 : TRACE :  end icon
33.060 : TRACE :  Icon:  bomb
33.060 : TRACE :  Stop NL 
33.060 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-16 should be possible to set both classes and icon for the node
33.061 : TRACE :  Long description: The root
33.061 : TRACE :  node end ... ]
33.061 : TRACE :  node found .. root
33.061 : DEBUG :  In get type [ ]
33.061 : INFO :  Node:  root
33.061 : TRACE :  Stop NL 
33.061 : TRACE :  Begin icon
33.061 : TRACE :  end icon
33.061 : TRACE :  Icon:  bomb
33.061 : TRACE :  Stop NL 
33.061 : TRACE :  Stop NL 
33.061 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-17 should be possible to use node syntax in the descriptions
33.061 : TRACE :  Starting NSTR
33.061 : TRACE :  description: String containing []
33.061 : TRACE :  node end ... ]
33.061 : TRACE :  node found .. root
33.061 : DEBUG :  In get type [ ]
33.061 : INFO :  Node:  root
33.061 : TRACE :  Stop NL 
33.061 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-18 should be possible to use node syntax in the descriptions in children
33.062 : TRACE :  Starting NSTR
33.062 : TRACE :  description: String containing []
33.062 : TRACE :  node end ... ]
33.062 : TRACE :  node found .. root
33.062 : DEBUG :  In get type [ ]
33.062 : INFO :  Node:  root
33.062 : TRACE :  Stop NL 
33.062 : TRACE :  Starting NSTR
33.062 : TRACE :  description: String containing ()
33.062 : TRACE :  node end ... ]
33.062 : TRACE :  node found .. child1
33.062 : DEBUG :  In get type [ ]
33.062 : INFO :  Node:  child1
33.062 : TRACE :  Stop NL 
33.062 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-19 should be possible to have a child after a class assignment
33.063 : TRACE :  Long description: Root
33.063 : TRACE :  node end )
33.063 : TRACE :  node found .. root
33.062 : DEBUG :  In get type ( )
33.062 : INFO :  Node:  root
33.063 : TRACE :  Stop NL 
33.063 : TRACE :  Long description: Child
33.063 : TRACE :  node end )
33.063 : TRACE :  node found .. Child
33.062 : DEBUG :  In get type ( )
33.062 : INFO :  Node:  Child
33.063 : TRACE :  Stop NL 
33.063 : TRACE :  Stop NL 
33.063 : TRACE :  Long description: a
33.063 : TRACE :  node end )
33.063 : TRACE :  node found .. a
33.062 : DEBUG :  In get type ( )
33.062 : INFO :  Node:  a
33.063 : TRACE :  Stop NL 
33.063 : TRACE :  Long description: New Stuff
33.063 : TRACE :  node end ... ]
33.063 : TRACE :  node found .. b
33.062 : DEBUG :  In get type [ ]
33.062 : INFO :  Node:  b
33.063 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-20 should be possible to have meaningless empty rows in a kanban abc124
33.064 : TRACE :  Long description: Root
33.064 : TRACE :  node end )
33.064 : TRACE :  node found .. root
33.064 : DEBUG :  In get type ( )
33.064 : INFO :  Node:  root
33.064 : TRACE :  Stop NL 
33.064 : TRACE :  Long description: Child
33.064 : TRACE :  node end )
33.064 : TRACE :  node found .. Child
33.064 : DEBUG :  In get type ( )
33.064 : INFO :  Node:  Child
33.064 : TRACE :  Stop NL 
33.064 : TRACE :  Long description: a
33.064 : TRACE :  node end )
33.064 : TRACE :  SPACELINE
33.064 : TRACE :  node found .. a
33.064 : DEBUG :  In get type ( )
33.064 : INFO :  Node:  a
33.064 : TRACE :  Long description: New Stuff
33.064 : TRACE :  node end ... ]
33.064 : TRACE :  node found .. b
33.064 : DEBUG :  In get type [ ]
33.064 : INFO :  Node:  b
33.064 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-21 should be possible to have comments in a kanban
33.066 : TRACE :  Long description: Root
33.066 : TRACE :  node end )
33.066 : TRACE :  node found .. root
33.066 : DEBUG :  In get type ( )
33.066 : INFO :  Node:  root
33.066 : TRACE :  Stop NL 
33.066 : TRACE :  Long description: Child
33.066 : TRACE :  node end )
33.066 : TRACE :  node found .. Child
33.066 : DEBUG :  In get type ( )
33.066 : INFO :  Node:  Child
33.066 : TRACE :  Stop NL 
33.066 : TRACE :  Long description: a
33.066 : TRACE :  node end )
33.066 : TRACE :  Found comment 

      %% This is a comment
33.066 : TRACE :  node found .. a
33.066 : DEBUG :  In get type ( )
33.066 : INFO :  Node:  a
33.066 : TRACE :  Stop NL2 
33.066 : TRACE :  Long description: New Stuff
33.066 : TRACE :  node end ... ]
33.066 : TRACE :  node found .. b
33.066 : DEBUG :  In get type [ ]
33.066 : INFO :  Node:  b
33.066 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-22 should be possible to have comments at the end of a line
33.068 : TRACE :  Long description: Root
33.068 : TRACE :  node end )
33.068 : TRACE :  node found .. root
33.068 : DEBUG :  In get type ( )
33.068 : INFO :  Node:  root
33.068 : TRACE :  Stop NL 
33.068 : TRACE :  Long description: Child
33.068 : TRACE :  node end )
33.068 : TRACE :  node found .. Child
33.068 : DEBUG :  In get type ( )
33.068 : INFO :  Node:  Child
33.068 : TRACE :  Stop NL 
33.068 : TRACE :  Long description: a
33.068 : TRACE :  node end )
33.068 : TRACE :  Found comment  %% This is a comment
33.068 : TRACE :  node found .. a
33.068 : DEBUG :  In get type ( )
33.068 : INFO :  Node:  a
33.068 : TRACE :  Stop NL2 
33.068 : TRACE :  Long description: New Stuff
33.068 : TRACE :  node end ... ]
33.068 : TRACE :  node found .. b
33.068 : DEBUG :  In get type [ ]
33.068 : INFO :  Node:  b
33.068 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-23 Rows with only spaces should not interfere
33.069 : TRACE :  Node:  root
33.069 : TRACE :  Stop NL 
33.069 : TRACE :  SPACELINE
33.069 : INFO :  Node:  A
33.069 : INFO :  Node:  B
33.069 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-24 Handle rows above the kanban declarations
33.070 : TRACE :  SPACELINE
33.070 : TRACE :  Node:  root
33.070 : TRACE :  Stop NL 
33.070 : TRACE :  SPACELINE
33.070 : INFO :  Node:  A
33.070 : INFO :  Node:  B
33.070 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-25 Handle rows above the kanban declarations, no space
33.070 : TRACE :  SPACELINE
33.070 : TRACE :  Node:  root
33.070 : TRACE :  Stop NL 
33.070 : TRACE :  SPACELINE
33.070 : INFO :  Node:  A
33.070 : INFO :  Node:  B
33.070 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-30 should be possible to set the priority
33.071 : INFO :  Node:  root
33.071 : TRACE :  Stop NL 
33.071 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-31 should be possible to set the assignment
33.072 : INFO :  Node:  root
33.072 : TRACE :  Stop NL 
33.072 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-32 should be possible to set the icon
33.073 : INFO :  Node:  root
33.073 : TRACE :  Stop NL 
33.073 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-33 should be possible to set the icon
33.073 : INFO :  Node:  root
33.073 : TRACE :  Stop NL 
33.073 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-34 should be possible to set the metadata using multiple lines
33.073 : INFO :  Node:  root
33.073 : TRACE :  Stop NL 
33.073 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-35 should be possible to set the metadata using one line
33.074 : INFO :  Node:  root
33.074 : TRACE :  Stop NL 
33.074 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-36 should be possible to set the label using the new syntax
33.074 : INFO :  Node:  root
33.074 : TRACE :  Stop NL 
33.074 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-37 should be possible to set the external id
33.074 : INFO :  Node:  root
33.074 : TRACE :  Stop NL 
33.074 : TRACE :  Stop EOF 

 ✓ packages/mermaid/src/diagrams/kanban/kanban.spec.ts  (30 tests) 34ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-text.spec.js  (342 tests) 171ms
 ❯ packages/mermaid/scripts/docs.spec.ts  (0 test)
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-edges.spec.js  (247 tests) 117ms
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
33.609 : DEBUG :  Opting in, graph 
33.609 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
33.609 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
33.609 : DEBUG :  Not a cluster  c Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
33.609 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
33.609 : DEBUG :  Cluster identified C2 Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
33.609 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
33.609 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} false false {} undefined  Depth  0
33.609 : DEBUG :  Not a cluster a 0
33.609 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} false false {} undefined  Depth  0
33.609 : DEBUG :  Not a cluster b 0
33.609 : DEBUG :  Extracting node c Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} false false {} undefined  Depth  0
33.609 : DEBUG :  Not a cluster c 0
33.609 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.609 : INFO :  cp  a  to  C1  with parent  C1
33.609 : INFO :  In copy  C1 root C1 data undefined C1
33.609 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.609 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'C2' } ]
33.609 : INFO :  Edge { v: 'a', w: 'b' }
33.609 : INFO :  Edge data {} C1
33.609 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
33.609 : INFO :  Edge is  { v: 'a', w: 'b' }
33.609 : INFO :  Copying as  a b {} undefined
33.609 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] {}
33.609 : INFO :  Edge { v: 'C1', w: 'C2' }
33.609 : INFO :  Edge data {} C1
33.609 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
33.609 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.609 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
33.609 : DEBUG :  Removing node a
33.609 : INFO :  cp  b  to  C1  with parent  C1
33.609 : INFO :  In copy  C1 root C1 data undefined C1
33.609 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.609 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.609 : INFO :  Edge { v: 'C1', w: 'C2' }
33.609 : INFO :  Edge data {} C1
33.609 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
33.609 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.609 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
33.609 : DEBUG :  Removing node b
33.609 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: {}, parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.609 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.609 : INFO :  cp  c  to  C2  with parent  C2
33.609 : INFO :  In copy  C2 root C2 data undefined C2
33.609 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.609 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.609 : INFO :  Edge { v: 'C1', w: 'C2' }
33.609 : INFO :  Edge data {} C2
33.609 : INFO :  Descendants of  C2  is  [ 'c' ]
33.609 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.609 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
33.609 : DEBUG :  Removing node c
33.609 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.609 : DEBUG :  Done, no node has children [ 'a', 'b' ]
33.609 : DEBUG :  Done, no node has children [ 'c' ]
33.609 : INFO :  [ { v: 'C1', w: 'C2' } ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
33.615 : DEBUG :  Opting in, graph 
33.615 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
33.615 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
33.615 : DEBUG :  Not a cluster  c Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
33.615 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
33.615 : DEBUG :  Cluster identified C2 Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
33.615 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
33.615 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false false { data: 1 } undefined  Depth  0
33.615 : DEBUG :  Not a cluster a 0
33.615 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false false { data: 2 } undefined  Depth  0
33.615 : DEBUG :  Not a cluster b 0
33.615 : DEBUG :  Extracting node c Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 3 } undefined  Depth  0
33.615 : DEBUG :  Not a cluster c 0
33.615 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} true true { data: 4 } undefined  Depth  0
33.615 : INFO :  cp  b  to  C1  with parent  C1
33.615 : INFO :  In copy  C1 root C1 data { data: 4 } C1
33.615 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.615 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'c' } ]
33.615 : INFO :  Edge { v: 'a', w: 'b' }
33.615 : INFO :  Edge data { name: 'C1-internal-link' } C1
33.615 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.615 : INFO :  Edge is  { v: 'a', w: 'b' }
33.615 : INFO :  Copying as  a b { name: 'C1-internal-link' } undefined
33.615 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] { name: 'C1-internal-link' }
33.615 : INFO :  Edge { v: 'C1', w: 'c' }
33.615 : INFO :  Edge data { name: 'C1-external-link' } C1
33.615 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.615 : INFO :  Edge is  { v: 'C1', w: 'c' }
33.615 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
33.615 : DEBUG :  Removing node b
33.615 : INFO :  cp  a  to  C1  with parent  C2
33.615 : DEBUG :  Setting parent a C2
33.615 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
33.615 : INFO :  Edge { v: 'C1', w: 'c' }
33.615 : INFO :  Edge data { name: 'C1-external-link' } C1
33.615 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.615 : INFO :  Edge is  { v: 'C1', w: 'c' }
33.615 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
33.615 : DEBUG :  Removing node a
33.615 : INFO :  cp  C2  to  C1  with parent  C2
33.615 : INFO :  In copy  C2 root C1 data { data: 5 } C1
33.615 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId true node!==clusterId false
33.615 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
33.615 : INFO :  Edge { v: 'C1', w: 'c' }
33.615 : INFO :  Edge data { name: 'C1-external-link' } C1
33.615 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.615 : INFO :  Edge is  { v: 'C1', w: 'c' }
33.615 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
33.615 : DEBUG :  Removing node C2
33.615 : DEBUG :  Removing node C2
33.615 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'c', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'c', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.615 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true undefined undefined  Depth  0
33.615 : DEBUG :  Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
33.615 : DEBUG :  Nodes =  [ 'b', 'a', 'C2' ] 1
33.615 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 2 } undefined  Depth  1
33.615 : DEBUG :  Not a cluster b 1
33.615 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false false { data: 1 } undefined  Depth  1
33.615 : DEBUG :  Not a cluster a 1
33.615 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 5 } undefined  Depth  1
33.615 : DEBUG :  Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
33.615 : INFO :  [ 'c', 'C1' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
33.618 : INFO :  [ 'a', 'b', 'C1', 'C2' ]
33.618 : DEBUG :  Opting in, graph 
33.618 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.618 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.618 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.618 : DEBUG :  Cluster identified C2 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.618 : DEBUG :  Nodes =  [ 'a', 'b', 'C1', 'C2' ] 0
33.618 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
33.618 : DEBUG :  Not a cluster a 0
33.618 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 2 } undefined  Depth  0
33.618 : DEBUG :  Not a cluster b 0
33.618 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
33.618 : INFO :  cp  a  to  C1  with parent  C1
33.618 : INFO :  In copy  C1 root C1 data undefined C1
33.618 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.618 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.618 : INFO :  Edge { v: 'C1', w: 'C2' }
33.618 : INFO :  Edge data { name: 'C1-external-link' } C1
33.618 : INFO :  Descendants of  C1  is  [ 'a' ]
33.618 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.618 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
33.618 : DEBUG :  Removing node a
33.618 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.618 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
33.618 : INFO :  cp  b  to  C2  with parent  C2
33.618 : INFO :  In copy  C2 root C2 data undefined C2
33.618 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.618 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.618 : INFO :  Edge { v: 'C1', w: 'C2' }
33.618 : INFO :  Edge data { name: 'C1-external-link' } C2
33.618 : INFO :  Descendants of  C2  is  [ 'b' ]
33.618 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.618 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
33.618 : DEBUG :  Removing node b
33.618 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.618 : DEBUG :  Done, no node has children [ 'a' ]
33.618 : DEBUG :  Done, no node has children [ 'b' ]
33.618 : INFO :  [ 'C1', 'C2' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
33.626 : DEBUG :  Opting in, graph 
33.626 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.626 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.626 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.626 : DEBUG :  Nodes =  [ 'a', 'b', 'C1' ] 0
33.626 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: { data: 3 } },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
33.626 : DEBUG :  Not a cluster a 0
33.626 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: { data: 3 } },
  'C2' => { id: 'b', clusterData: undefined }
} false true { data: 2 } undefined  Depth  0
33.626 : DEBUG :  Not a cluster b 0
33.626 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: { data: 3 } },
  'C2' => { id: 'b', clusterData: undefined }
} true true { data: 3 } undefined  Depth  0
33.626 : INFO :  cp  a  to  C1  with parent  C1
33.626 : INFO :  In copy  C1 root C1 data { data: 3 } C1
33.626 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.626 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' } ]
33.626 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
33.626 : INFO :  Edge data { data: 'link1' } C1
33.626 : INFO :  Descendants of  C1  is  [ 'a' ]
33.626 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
33.626 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
33.626 : DEBUG :  Removing node a
33.626 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.626 : DEBUG :  Done, no node has children [ 'a' ]
33.626 : INFO :  [ { v: 'C1', w: 'b', name: '1' } ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
33.627 : INFO :  { data: 4 }
33.627 : DEBUG :  Opting in, graph 
33.627 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.627 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.627 : DEBUG :  Not a cluster  c Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.627 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
33.627 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1' ] 0
33.627 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
33.627 : DEBUG :  Not a cluster a 0
33.627 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} false true { data: 2 } undefined  Depth  0
33.627 : DEBUG :  Not a cluster b 0
33.627 : DEBUG :  Extracting node c Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} false true { data: 3 } undefined  Depth  0
33.627 : DEBUG :  Not a cluster c 0
33.627 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} true true { data: 4 } undefined  Depth  0
33.627 : INFO :  cp  a  to  C1  with parent  C1
33.627 : INFO :  In copy  C1 root C1 data { data: 4 } C1
33.627 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.627 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]
33.627 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
33.627 : INFO :  Edge data { data: 'link1' } C1
33.627 : INFO :  Descendants of  C1  is  [ 'a' ]
33.627 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
33.627 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
33.627 : INFO :  Edge { v: 'C1', w: 'c', name: '2' }
33.627 : INFO :  Edge data { data: 'link2' } C1
33.627 : INFO :  Descendants of  C1  is  [ 'a' ]
33.627 : INFO :  Edge is  { v: 'C1', w: 'c', name: '2' }
33.627 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
33.627 : DEBUG :  Removing node a
33.627 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object] },
    { v: 'C1', value: [Object] }
  ],
  edges: [
    { v: 'C1', w: 'b', name: '1', value: [Object] },
    { v: 'C1', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.627 : DEBUG :  Done, no node has children [ 'a' ]
33.627 : INFO :  [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
33.628 : DEBUG :  Opting in, graph 
33.628 : DEBUG :  Not a cluster  a Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
33.628 : DEBUG :  Not a cluster  b Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
33.628 : DEBUG :  Not a cluster  c Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
33.628 : DEBUG :  Cluster identified A Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
33.628 : DEBUG :  Cluster identified B Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
33.628 : DEBUG :  Cluster identified C Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
33.628 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'A', 'B', 'C' ] 0
33.628 : DEBUG :  Extracting node a Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
33.628 : DEBUG :  Not a cluster a 0
33.628 : DEBUG :  Extracting node b Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} false false { data: 2 } undefined  Depth  0
33.628 : DEBUG :  Not a cluster b 0
33.628 : DEBUG :  Extracting node c Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} false false { data: 3 } undefined  Depth  0
33.628 : DEBUG :  Not a cluster c 0
33.628 : DEBUG :  Extracting node A Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.628 : INFO :  cp  a  to  A  with parent  A
33.628 : INFO :  In copy  A root A data undefined A
33.628 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.628 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.628 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Edge data { data: 'link1' } A
33.628 : INFO :  Descendants of  A  is  [ 'a' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
33.628 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Edge data { data: 'link2' } A
33.628 : INFO :  Descendants of  A  is  [ 'a' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
33.628 : DEBUG :  Removing node a
33.628 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B' },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Extracting node B Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.628 : INFO :  cp  b  to  B  with parent  B
33.628 : INFO :  In copy  B root B data undefined B
33.628 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.628 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.628 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Edge data { data: 'link1' } B
33.628 : INFO :  Descendants of  B  is  [ 'b' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
33.628 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Edge data { data: 'link2' } B
33.628 : INFO :  Descendants of  B  is  [ 'b' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
33.628 : DEBUG :  Removing node b
33.628 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Extracting node C Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.628 : INFO :  cp  c  to  C  with parent  C
33.628 : INFO :  In copy  C root C data undefined C
33.628 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.628 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.628 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Edge data { data: 'link1' } C
33.628 : INFO :  Descendants of  C  is  [ 'c' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
33.628 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Edge data { data: 'link2' } C
33.628 : INFO :  Descendants of  C  is  [ 'c' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
33.628 : DEBUG :  Removing node c
33.628 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Done, no node has children [ 'a' ]
33.628 : DEBUG :  Done, no node has children [ 'b' ]
33.628 : DEBUG :  Done, no node has children [ 'c' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
33.631 : DEBUG :  Opting in, graph 
33.631 : DEBUG :  Cluster identified C Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.631 : DEBUG :  Cluster identified D Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.631 : DEBUG :  Not a cluster  d Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.631 : DEBUG :  Nodes =  [ 'C', 'D', 'd' ] 0
33.631 : DEBUG :  Extracting node C Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
33.631 : INFO :  cp  d  to  C  with parent  D
33.631 : DEBUG :  Setting parent d D
33.631 : DEBUG :  Copying Edges []
33.631 : DEBUG :  Removing node d
33.631 : INFO :  cp  D  to  C  with parent  D
33.631 : INFO :  In copy  D root C data { data: 2 } C
33.631 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
33.631 : DEBUG :  Copying Edges []
33.631 : DEBUG :  Removing node D
33.631 : DEBUG :  Removing node D
33.631 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.631 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
33.631 : DEBUG :  Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
}
33.631 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
33.631 : DEBUG :  Not a cluster d 0
33.631 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
33.631 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false false { data: 3 } [ 'd' ]  Depth  1
33.631 : DEBUG :  Not a cluster d 1
33.631 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
33.631 : INFO :  cp  d  to  D  with parent  D
33.631 : INFO :  In copy  D root D data { data: 2 } D
33.631 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
33.631 : DEBUG :  Copying Edges []
33.631 : DEBUG :  Removing node d
33.631 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.631 : DEBUG :  Done, no node has children [ 'd' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
33.633 : INFO :  Graph before { data: 2 }
33.633 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'D', value: [Object], parent: 'C' },
    { v: 'd', value: [Object], parent: 'D' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.633 : DEBUG :  Opting in, graph 
33.633 : DEBUG :  Cluster identified C Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.633 : DEBUG :  Cluster identified D Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.633 : DEBUG :  Not a cluster  d Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.633 : DEBUG :  Cluster identified B Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.633 : DEBUG :  Not a cluster  b Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.633 : DEBUG :  Cluster identified A Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.633 : DEBUG :  Not a cluster  a Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
33.633 : DEBUG :  Nodes =  [
  'C', 'D', 'd',
  'B', 'b', 'A',
  'a'
] 0
33.633 : DEBUG :  Extracting node C Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
33.633 : INFO :  cp  d  to  C  with parent  D
33.633 : DEBUG :  Setting parent d D
33.633 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.633 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Edge data { data: 'link1' } C
33.633 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
33.633 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Edge data { data: 'link2' } C
33.633 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
33.633 : DEBUG :  Removing node d
33.633 : INFO :  cp  D  to  C  with parent  D
33.633 : INFO :  In copy  D root C data { data: 2 } C
33.633 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
33.633 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.633 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Edge data { data: 'link1' } C
33.633 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
33.633 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Edge data { data: 'link2' } C
33.633 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
33.633 : DEBUG :  Removing node D
33.633 : DEBUG :  Removing node D
33.633 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.633 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
33.633 : DEBUG :  Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
}
33.633 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
33.633 : DEBUG :  Not a cluster d 0
33.633 : DEBUG :  Extracting node B Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 4 } undefined  Depth  0
33.633 : INFO :  cp  b  to  B  with parent  B
33.633 : INFO :  In copy  B root B data { data: 4 } B
33.633 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.633 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.633 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Edge data { data: 'link1' } B
33.633 : INFO :  Descendants of  B  is  [ 'b' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
33.633 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Edge data { data: 'link2' } B
33.633 : INFO :  Descendants of  B  is  [ 'b' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
33.633 : DEBUG :  Removing node b
33.633 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.633 : DEBUG :  Extracting node b Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
33.633 : DEBUG :  Not a cluster b 0
33.633 : DEBUG :  Extracting node A Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 6 } undefined  Depth  0
33.633 : INFO :  cp  a  to  A  with parent  A
33.633 : INFO :  In copy  A root A data { data: 6 } A
33.633 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.633 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.633 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Edge data { data: 'link1' } A
33.633 : INFO :  Descendants of  A  is  [ 'a' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.633 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
33.633 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Edge data { data: 'link2' } A
33.633 : INFO :  Descendants of  A  is  [ 'a' ]
33.633 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.633 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
33.633 : DEBUG :  Removing node a
33.633 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.633 : DEBUG :  Extracting node a Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
33.633 : DEBUG :  Not a cluster a 0
33.633 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
33.633 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false false { data: 3 } [ 'd' ]  Depth  1
33.633 : DEBUG :  Not a cluster d 1
33.633 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
33.633 : INFO :  cp  d  to  D  with parent  D
33.633 : INFO :  In copy  D root D data { data: 2 } D
33.633 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
33.633 : DEBUG :  Copying Edges []
33.633 : DEBUG :  Removing node d
33.633 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.633 : DEBUG :  Done, no node has children [ 'd' ]
33.633 : DEBUG :  Done, no node has children [ 'b' ]
33.633 : DEBUG :  Done, no node has children [ 'a' ]
33.633 : INFO :  A [ 'a' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
33.636 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'd', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'b' }
  ],
  edges: [
    { v: 'a', w: 'b', name: '1', value: [Object] },
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.636 : DEBUG :  Opting in, graph 
33.636 : DEBUG :  Not a cluster  a Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
33.636 : DEBUG :  Cluster identified b Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
33.636 : DEBUG :  Not a cluster  c Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
33.636 : DEBUG :  Not a cluster  d Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
33.636 : DEBUG :  Not a cluster  e Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
33.636 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'd', 'e' ] 0
33.636 : DEBUG :  Extracting node a Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true { data: 1 } undefined  Depth  0
33.636 : DEBUG :  Not a cluster a 0
33.636 : DEBUG :  Extracting node b Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} true true { data: 2 } undefined  Depth  0
33.636 : INFO :  cp  c  to  b  with parent  b
33.636 : INFO :  In copy  b root b data { data: 2 } b
33.636 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.636 : DEBUG :  Copying Edges [
  { v: 'c', w: 'd', name: '2' },
  { v: 'd', w: 'e', name: '2' },
  { v: 'a', w: 'b', name: '1' }
]
33.636 : INFO :  Edge { v: 'c', w: 'd', name: '2' }
33.636 : INFO :  Edge data { data: 'link2' } b
33.636 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.636 : INFO :  Edge is  { v: 'c', w: 'd', name: '2' }
33.636 : INFO :  Copying as  c d { data: 'link2' } 2
33.636 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' } ] { data: 'link2' }
33.636 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
33.636 : INFO :  Edge data { data: 'link2' } b
33.636 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.636 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
33.636 : INFO :  Copying as  d e { data: 'link2' } 2
33.636 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
33.636 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
33.636 : INFO :  Edge data { data: 'link1' } b
33.636 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.636 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
33.636 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
33.636 : DEBUG :  Removing node c
33.636 : INFO :  cp  d  to  b  with parent  b
33.636 : INFO :  In copy  b root b data { data: 2 } b
33.636 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
33.636 : DEBUG :  Copying Edges [ { v: 'd', w: 'e', name: '2' }, { v: 'a', w: 'b', name: '1' } ]
33.636 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
33.636 : INFO :  Edge data { data: 'link2' } b
33.636 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.636 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
33.636 : INFO :  Copying as  d e { data: 'link2' } 2
33.636 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
33.636 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
33.636 : INFO :  Edge data { data: 'link1' } b
33.636 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.636 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
33.636 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
33.636 : DEBUG :  Removing node d
33.636 : INFO :  cp  e  to  b  with parent  b
33.636 : INFO :  In copy  b root b data { data: 2 } b
33.636 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
33.636 : DEBUG :  Copying Edges [ { v: 'a', w: 'b', name: '1' } ]
33.636 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
33.636 : INFO :  Edge data { data: 'link1' } b
33.636 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.636 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
33.636 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
33.636 : DEBUG :  Removing node e
33.636 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] }, { v: 'b', value: [Object] } ],
  edges: [ { v: 'a', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.636 : DEBUG :  Extracting node c Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
33.636 : DEBUG :  Not a cluster c 0
33.636 : DEBUG :  Extracting node d Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
33.636 : DEBUG :  Not a cluster d 0
33.636 : DEBUG :  Extracting node e Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
33.636 : DEBUG :  Not a cluster e 0
33.636 : DEBUG :  Done, no node has children [ 'c', 'd', 'e' ]
33.636 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object] },
    { v: 'd', value: [Object] },
    { v: 'e', value: [Object] }
  ],
  edges: [
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
33.637 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object], parent: 'a' },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'c' }
  ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.637 : DEBUG :  Opting in, graph 
33.637 : DEBUG :  Cluster identified a Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.637 : DEBUG :  Cluster identified b Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.637 : DEBUG :  Cluster identified c Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.637 : DEBUG :  Not a cluster  e Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.637 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'e' ] 0
33.637 : DEBUG :  Extracting node a Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true { data: 1 } undefined  Depth  0
33.637 : INFO :  cp  e  to  a  with parent  c
33.637 : DEBUG :  Setting parent e c
33.637 : DEBUG :  Copying Edges []
33.637 : DEBUG :  Removing node e
33.637 : INFO :  cp  c  to  a  with parent  c
33.637 : INFO :  In copy  c root a data { data: 3 } a
33.637 : DEBUG :  Not Setting parent for node= c cluster!==rootId true node!==clusterId false
33.637 : DEBUG :  Copying Edges []
33.637 : DEBUG :  Removing node c
33.637 : DEBUG :  Removing node c
33.637 : INFO :  cp  b  to  a  with parent  b
33.637 : INFO :  In copy  b root a data { data: 2 } a
33.637 : DEBUG :  Not Setting parent for node= b cluster!==rootId true node!==clusterId false
33.637 : DEBUG :  Copying Edges []
33.637 : DEBUG :  Removing node b
33.637 : DEBUG :  Removing node b
33.637 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.637 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.637 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.637 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.637 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.637 : DEBUG :  Extracting node e Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false true undefined undefined  Depth  0
33.637 : DEBUG :  Not a cluster e 0
33.637 : DEBUG :  Nodes =  [ 'e', 'c', 'b' ] 1
33.637 : DEBUG :  Extracting node e Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false false { data: 3 } undefined  Depth  1
33.637 : DEBUG :  Not a cluster e 1
33.637 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true false { data: 3 } undefined  Depth  1
33.637 : INFO :  cp  e  to  c  with parent  c
33.637 : INFO :  In copy  c root c data { data: 3 } c
33.637 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
33.637 : DEBUG :  Copying Edges []
33.637 : DEBUG :  Removing node e
33.637 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'b', value: [Object] }
  ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.637 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true { data: 2 } undefined  Depth  1
33.637 : INFO :  cp  c  to  b  with parent  b
33.637 : INFO :  In copy  b root b data { data: 2 } b
33.637 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.637 : DEBUG :  Copying Edges []
33.637 : DEBUG :  Removing node c
33.637 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.637 : DEBUG :  Done, no node has children [ 'c' ]
33.637 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
33.638 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object], parent: 'A' },
    { v: 'b', value: [Object], parent: 'A' },
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'b', w: 'B', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.638 : DEBUG :  Opting in, graph 
33.638 : DEBUG :  Cluster identified A Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.638 : DEBUG :  Cluster identified B Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.638 : DEBUG :  Not a cluster  b Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.638 : DEBUG :  Not a cluster  c Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.638 : DEBUG :  Not a cluster  a Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
33.638 : DEBUG :  Nodes =  [ 'A', 'B', 'b', 'c', 'a' ] 0
33.638 : DEBUG :  Extracting node A Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  cssClass: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  0
33.638 : INFO :  cp  c  to  A  with parent  B
33.638 : DEBUG :  Setting parent c B
33.638 : DEBUG :  Copying Edges [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ]
33.638 : INFO :  Edge { v: 'b', w: 'c', name: '1' }
33.638 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} A
33.638 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
33.638 : INFO :  Edge is  { v: 'b', w: 'c', name: '1' }
33.638 : INFO :  Copying as  b c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} 1
33.638 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
33.638 : INFO :  Edge { v: 'a', w: 'c', name: '2' }
33.638 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  cssClasses: 'flowchart-link LS-a LE-c'
} A
33.638 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
33.638 : INFO :  Edge is  { v: 'a', w: 'c', name: '2' }
33.638 : INFO :  Copying as  a c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  cssClasses: 'flowchart-link LS-a LE-c'
} 2
33.638 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
33.638 : DEBUG :  Removing node c
33.638 : INFO :  cp  B  to  A  with parent  B
33.638 : INFO :  In copy  B root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} A
33.638 : DEBUG :  Not Setting parent for node= B cluster!==rootId true node!==clusterId false
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node B
33.638 : DEBUG :  Removing node B
33.638 : INFO :  cp  b  to  A  with parent  A
33.638 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  cssClass: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
33.638 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node b
33.638 : INFO :  cp  a  to  A  with parent  A
33.638 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  cssClass: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
33.638 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node a
33.638 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'A', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.638 : DEBUG :  Extracting node B Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false true undefined undefined  Depth  0
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node a Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Nodes =  [ 'c', 'B', 'b', 'a' ] 1
33.638 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true false {
  labelStyle: '',
  shape: 'rect',
  labelText: 'c',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'c',
  padding: 15
} undefined  Depth  1
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node B Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  1
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'b',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'b',
  padding: 15
} undefined  Depth  1
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node a Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'a',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'a',
  padding: 15
} undefined  Depth  1
33.638 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
33.638 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'a', value: [Object] }
  ],
  edges: [
    { v: 'b', w: 'c', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

 ✓ packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js  (15 tests) 36ms
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
33.613 : DEBUG :  Opting in, graph 
33.613 : DEBUG :  Not a cluster  a { C1: [ 'a', 'b' ], C2: [ 'c' ] }
33.613 : DEBUG :  Not a cluster  b { C1: [ 'a', 'b' ], C2: [ 'c' ] }
33.613 : DEBUG :  Not a cluster  c { C1: [ 'a', 'b' ], C2: [ 'c' ] }
33.613 : DEBUG :  Cluster identified C1 { C1: [ 'a', 'b' ], C2: [ 'c' ] }
33.613 : DEBUG :  Cluster identified C2 { C1: [ 'a', 'b' ], C2: [ 'c' ] }
33.613 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
33.613 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} undefined false {} undefined  Depth  0
33.613 : DEBUG :  Not a cluster a 0
33.613 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} undefined false {} undefined  Depth  0
33.613 : DEBUG :  Not a cluster b 0
33.613 : DEBUG :  Extracting node c {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} undefined false {} undefined  Depth  0
33.613 : DEBUG :  Not a cluster c 0
33.613 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.613 : INFO :  cp  a  to  C1  with parent  C1
33.613 : INFO :  In copy  C1 root C1 data undefined C1
33.613 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.613 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'C2' } ]
33.613 : INFO :  Edge { v: 'a', w: 'b' }
33.613 : INFO :  Edge data {} C1
33.613 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
33.613 : INFO :  Edge is  { v: 'a', w: 'b' }
33.613 : INFO :  Copying as  a b {} undefined
33.613 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] {}
33.613 : INFO :  Edge { v: 'C1', w: 'C2' }
33.613 : INFO :  Edge data {} C1
33.613 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
33.613 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.613 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
33.613 : DEBUG :  Removing node a
33.613 : INFO :  cp  b  to  C1  with parent  C1
33.613 : INFO :  In copy  C1 root C1 data undefined C1
33.613 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.613 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.613 : INFO :  Edge { v: 'C1', w: 'C2' }
33.613 : INFO :  Edge data {} C1
33.613 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
33.613 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.613 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
33.613 : DEBUG :  Removing node b
33.613 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: {}, parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.613 : DEBUG :  Extracting node C2 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.613 : INFO :  cp  c  to  C2  with parent  C2
33.613 : INFO :  In copy  C2 root C2 data undefined C2
33.613 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.613 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.613 : INFO :  Edge { v: 'C1', w: 'C2' }
33.613 : INFO :  Edge data {} C2
33.613 : INFO :  Descendants of  C2  is  [ 'c' ]
33.613 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.613 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
33.613 : DEBUG :  Removing node c
33.613 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.613 : DEBUG :  Done, no node has children [ 'a', 'b' ]
33.613 : DEBUG :  Done, no node has children [ 'c' ]
33.613 : INFO :  [ { v: 'C1', w: 'C2' } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
33.620 : DEBUG :  Opting in, graph 
33.620 : DEBUG :  Not a cluster  a { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
33.620 : DEBUG :  Not a cluster  b { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
33.620 : DEBUG :  Not a cluster  c { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
33.620 : DEBUG :  Cluster identified C1 { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
33.620 : DEBUG :  Cluster identified C2 { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
33.620 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
33.620 : DEBUG :  Extracting node a {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined false { data: 1 } undefined  Depth  0
33.620 : DEBUG :  Not a cluster a 0
33.620 : DEBUG :  Extracting node b {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined false { data: 2 } undefined  Depth  0
33.620 : DEBUG :  Not a cluster b 0
33.620 : DEBUG :  Extracting node c {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined true { data: 3 } undefined  Depth  0
33.620 : DEBUG :  Not a cluster c 0
33.620 : DEBUG :  Extracting node C1 {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} true true { data: 4 } undefined  Depth  0
33.620 : INFO :  cp  b  to  C1  with parent  C1
33.620 : INFO :  In copy  C1 root C1 data { data: 4 } C1
33.620 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.620 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'c' } ]
33.620 : INFO :  Edge { v: 'a', w: 'b' }
33.620 : INFO :  Edge data { name: 'C1-internal-link' } C1
33.620 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.620 : INFO :  Edge is  { v: 'a', w: 'b' }
33.620 : INFO :  Copying as  a b { name: 'C1-internal-link' } undefined
33.620 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] { name: 'C1-internal-link' }
33.620 : INFO :  Edge { v: 'C1', w: 'c' }
33.620 : INFO :  Edge data { name: 'C1-external-link' } C1
33.620 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.620 : INFO :  Edge is  { v: 'C1', w: 'c' }
33.620 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
33.620 : DEBUG :  Removing node b
33.620 : INFO :  cp  a  to  C1  with parent  C2
33.620 : DEBUG :  Setting parent a C2
33.620 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
33.620 : INFO :  Edge { v: 'C1', w: 'c' }
33.620 : INFO :  Edge data { name: 'C1-external-link' } C1
33.620 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.620 : INFO :  Edge is  { v: 'C1', w: 'c' }
33.620 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
33.620 : DEBUG :  Removing node a
33.620 : INFO :  cp  C2  to  C1  with parent  C2
33.620 : INFO :  In copy  C2 root C1 data { data: 5 } C1
33.620 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId true node!==clusterId false
33.620 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
33.620 : INFO :  Edge { v: 'C1', w: 'c' }
33.620 : INFO :  Edge data { name: 'C1-external-link' } C1
33.620 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
33.620 : INFO :  Edge is  { v: 'C1', w: 'c' }
33.620 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
33.620 : DEBUG :  Removing node C2
33.620 : DEBUG :  Removing node C2
33.620 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'c', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'c', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.620 : DEBUG :  Extracting node C2 {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true undefined undefined  Depth  0
33.620 : DEBUG :  {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
33.620 : DEBUG :  Nodes =  [ 'b', 'a', 'C2' ] 1
33.620 : DEBUG :  Extracting node b {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined true { data: 2 } undefined  Depth  1
33.620 : DEBUG :  Not a cluster b 1
33.620 : DEBUG :  Extracting node a {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined false { data: 1 } undefined  Depth  1
33.620 : DEBUG :  Not a cluster a 1
33.620 : DEBUG :  Extracting node C2 {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 5 } undefined  Depth  1
33.620 : DEBUG :  {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
33.620 : INFO :  [ 'c', 'C1' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
33.622 : INFO :  [ 'a', 'b', 'C1', 'C2' ]
33.622 : DEBUG :  Opting in, graph 
33.622 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ] }
33.622 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ] }
33.622 : DEBUG :  Cluster identified C1 { C1: [ 'a' ], C2: [ 'b' ] }
33.622 : DEBUG :  Cluster identified C2 { C1: [ 'a' ], C2: [ 'b' ] }
33.622 : DEBUG :  Nodes =  [ 'a', 'b', 'C1', 'C2' ] 0
33.622 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
33.622 : DEBUG :  Not a cluster a 0
33.622 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 2 } undefined  Depth  0
33.622 : DEBUG :  Not a cluster b 0
33.622 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
33.622 : INFO :  cp  a  to  C1  with parent  C1
33.622 : INFO :  In copy  C1 root C1 data undefined C1
33.622 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.622 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.622 : INFO :  Edge { v: 'C1', w: 'C2' }
33.622 : INFO :  Edge data { name: 'C1-external-link' } C1
33.622 : INFO :  Descendants of  C1  is  [ 'a' ]
33.622 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.622 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
33.622 : DEBUG :  Removing node a
33.622 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.622 : DEBUG :  Extracting node C2 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
33.622 : INFO :  cp  b  to  C2  with parent  C2
33.622 : INFO :  In copy  C2 root C2 data undefined C2
33.622 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.622 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
33.622 : INFO :  Edge { v: 'C1', w: 'C2' }
33.622 : INFO :  Edge data { name: 'C1-external-link' } C2
33.622 : INFO :  Descendants of  C2  is  [ 'b' ]
33.622 : INFO :  Edge is  { v: 'C1', w: 'C2' }
33.622 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
33.622 : DEBUG :  Removing node b
33.622 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.622 : DEBUG :  Done, no node has children [ 'a' ]
33.622 : DEBUG :  Done, no node has children [ 'b' ]
33.622 : INFO :  [ 'C1', 'C2' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
33.623 : DEBUG :  Opting in, graph 
33.623 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ] }
33.623 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ] }
33.623 : DEBUG :  Cluster identified C1 { C1: [ 'a' ], C2: [ 'b' ] }
33.623 : DEBUG :  Nodes =  [ 'a', 'b', 'C1' ] 0
33.623 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: { data: 3 } },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
33.623 : DEBUG :  Not a cluster a 0
33.623 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: { data: 3 } },
  C2: { id: 'b', clusterData: undefined }
} undefined true { data: 2 } undefined  Depth  0
33.623 : DEBUG :  Not a cluster b 0
33.623 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: { data: 3 } },
  C2: { id: 'b', clusterData: undefined }
} true true { data: 3 } undefined  Depth  0
33.623 : INFO :  cp  a  to  C1  with parent  C1
33.623 : INFO :  In copy  C1 root C1 data { data: 3 } C1
33.623 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.623 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' } ]
33.623 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
33.623 : INFO :  Edge data { data: 'link1' } C1
33.623 : INFO :  Descendants of  C1  is  [ 'a' ]
33.623 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
33.623 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
33.623 : DEBUG :  Removing node a
33.623 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.623 : DEBUG :  Done, no node has children [ 'a' ]
33.623 : INFO :  [ { v: 'C1', w: 'b', name: '1' } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
33.624 : INFO :  { data: 4 }
33.624 : DEBUG :  Opting in, graph 
33.624 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ] }
33.624 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ] }
33.624 : DEBUG :  Not a cluster  c { C1: [ 'a' ], C2: [ 'b' ] }
33.624 : DEBUG :  Cluster identified C1 { C1: [ 'a' ], C2: [ 'b' ] }
33.624 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1' ] 0
33.624 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
33.624 : DEBUG :  Not a cluster a 0
33.624 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} undefined true { data: 2 } undefined  Depth  0
33.624 : DEBUG :  Not a cluster b 0
33.624 : DEBUG :  Extracting node c {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} undefined true { data: 3 } undefined  Depth  0
33.624 : DEBUG :  Not a cluster c 0
33.624 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} true true { data: 4 } undefined  Depth  0
33.624 : INFO :  cp  a  to  C1  with parent  C1
33.624 : INFO :  In copy  C1 root C1 data { data: 4 } C1
33.624 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.624 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]
33.624 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
33.624 : INFO :  Edge data { data: 'link1' } C1
33.624 : INFO :  Descendants of  C1  is  [ 'a' ]
33.624 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
33.624 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
33.624 : INFO :  Edge { v: 'C1', w: 'c', name: '2' }
33.624 : INFO :  Edge data { data: 'link2' } C1
33.624 : INFO :  Descendants of  C1  is  [ 'a' ]
33.624 : INFO :  Edge is  { v: 'C1', w: 'c', name: '2' }
33.624 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
33.624 : DEBUG :  Removing node a
33.624 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object] },
    { v: 'C1', value: [Object] }
  ],
  edges: [
    { v: 'C1', w: 'b', name: '1', value: [Object] },
    { v: 'C1', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.624 : DEBUG :  Done, no node has children [ 'a' ]
33.624 : INFO :  [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
33.625 : DEBUG :  Opting in, graph 
33.625 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
33.625 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
33.625 : DEBUG :  Not a cluster  c { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
33.625 : DEBUG :  Cluster identified A { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
33.625 : DEBUG :  Cluster identified B { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
33.625 : DEBUG :  Cluster identified C { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
33.625 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'A', 'B', 'C' ] 0
33.625 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
33.625 : DEBUG :  Not a cluster a 0
33.625 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} undefined false { data: 2 } undefined  Depth  0
33.625 : DEBUG :  Not a cluster b 0
33.625 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} undefined false { data: 3 } undefined  Depth  0
33.625 : DEBUG :  Not a cluster c 0
33.625 : DEBUG :  Extracting node A {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.625 : INFO :  cp  a  to  A  with parent  A
33.625 : INFO :  In copy  A root A data undefined A
33.625 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.625 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.625 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.625 : INFO :  Edge data { data: 'link1' } A
33.625 : INFO :  Descendants of  A  is  [ 'a' ]
33.625 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.625 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
33.625 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.625 : INFO :  Edge data { data: 'link2' } A
33.625 : INFO :  Descendants of  A  is  [ 'a' ]
33.625 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.625 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
33.625 : DEBUG :  Removing node a
33.625 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B' },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.625 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.625 : INFO :  cp  b  to  B  with parent  B
33.625 : INFO :  In copy  B root B data undefined B
33.625 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.625 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.625 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.625 : INFO :  Edge data { data: 'link1' } B
33.625 : INFO :  Descendants of  B  is  [ 'b' ]
33.625 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.625 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
33.625 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.625 : INFO :  Edge data { data: 'link2' } B
33.625 : INFO :  Descendants of  B  is  [ 'b' ]
33.625 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.625 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
33.625 : DEBUG :  Removing node b
33.625 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.625 : DEBUG :  Extracting node C {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
33.625 : INFO :  cp  c  to  C  with parent  C
33.625 : INFO :  In copy  C root C data undefined C
33.625 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.625 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.625 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.625 : INFO :  Edge data { data: 'link1' } C
33.625 : INFO :  Descendants of  C  is  [ 'c' ]
33.625 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.625 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
33.625 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.625 : INFO :  Edge data { data: 'link2' } C
33.625 : INFO :  Descendants of  C  is  [ 'c' ]
33.625 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.625 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
33.625 : DEBUG :  Removing node c
33.625 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.625 : DEBUG :  Done, no node has children [ 'a' ]
33.625 : DEBUG :  Done, no node has children [ 'b' ]
33.625 : DEBUG :  Done, no node has children [ 'c' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
33.627 : DEBUG :  Opting in, graph 
33.627 : DEBUG :  Cluster identified C {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.627 : DEBUG :  Cluster identified D {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.627 : DEBUG :  Not a cluster  d {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.627 : DEBUG :  Nodes =  [ 'C', 'D', 'd' ] 0
33.627 : DEBUG :  Extracting node C {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
33.627 : INFO :  cp  d  to  C  with parent  D
33.627 : DEBUG :  Setting parent d D
33.627 : DEBUG :  Copying Edges []
33.627 : DEBUG :  Removing node d
33.627 : INFO :  cp  D  to  C  with parent  D
33.627 : INFO :  In copy  D root C data { data: 2 } C
33.627 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
33.627 : DEBUG :  Copying Edges []
33.627 : DEBUG :  Removing node D
33.627 : DEBUG :  Removing node D
33.627 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.627 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
33.627 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
}
33.627 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
33.627 : DEBUG :  Not a cluster d 0
33.627 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
33.627 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined false { data: 3 } [ 'd' ]  Depth  1
33.627 : DEBUG :  Not a cluster d 1
33.627 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
33.627 : INFO :  cp  d  to  D  with parent  D
33.627 : INFO :  In copy  D root D data { data: 2 } D
33.627 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
33.627 : DEBUG :  Copying Edges []
33.627 : DEBUG :  Removing node d
33.627 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.627 : DEBUG :  Done, no node has children [ 'd' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
33.628 : INFO :  Graph before { data: 2 }
33.628 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'D', value: [Object], parent: 'C' },
    { v: 'd', value: [Object], parent: 'D' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Opting in, graph 
33.628 : DEBUG :  Cluster identified C {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.628 : DEBUG :  Cluster identified D {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.628 : DEBUG :  Not a cluster  d {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.628 : DEBUG :  Cluster identified B {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.628 : DEBUG :  Not a cluster  b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.628 : DEBUG :  Cluster identified A {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.628 : DEBUG :  Not a cluster  a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
33.628 : DEBUG :  Nodes =  [
  'C', 'D', 'd',
  'B', 'b', 'A',
  'a'
] 0
33.628 : DEBUG :  Extracting node C {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
33.628 : INFO :  cp  d  to  C  with parent  D
33.628 : DEBUG :  Setting parent d D
33.628 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.628 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Edge data { data: 'link1' } C
33.628 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
33.628 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Edge data { data: 'link2' } C
33.628 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
33.628 : DEBUG :  Removing node d
33.628 : INFO :  cp  D  to  C  with parent  D
33.628 : INFO :  In copy  D root C data { data: 2 } C
33.628 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
33.628 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.628 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Edge data { data: 'link1' } C
33.628 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
33.628 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Edge data { data: 'link2' } C
33.628 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
33.628 : DEBUG :  Removing node D
33.628 : DEBUG :  Removing node D
33.628 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
33.628 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
}
33.628 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
33.628 : DEBUG :  Not a cluster d 0
33.628 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 4 } undefined  Depth  0
33.628 : INFO :  cp  b  to  B  with parent  B
33.628 : INFO :  In copy  B root B data { data: 4 } B
33.628 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.628 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.628 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Edge data { data: 'link1' } B
33.628 : INFO :  Descendants of  B  is  [ 'b' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
33.628 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Edge data { data: 'link2' } B
33.628 : INFO :  Descendants of  B  is  [ 'b' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
33.628 : DEBUG :  Removing node b
33.628 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
33.628 : DEBUG :  Not a cluster b 0
33.628 : DEBUG :  Extracting node A {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 6 } undefined  Depth  0
33.628 : INFO :  cp  a  to  A  with parent  A
33.628 : INFO :  In copy  A root A data { data: 6 } A
33.628 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.628 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
33.628 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Edge data { data: 'link1' } A
33.628 : INFO :  Descendants of  A  is  [ 'a' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
33.628 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
33.628 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Edge data { data: 'link2' } A
33.628 : INFO :  Descendants of  A  is  [ 'a' ]
33.628 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
33.628 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
33.628 : DEBUG :  Removing node a
33.628 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
33.628 : DEBUG :  Not a cluster a 0
33.628 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
33.628 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined false { data: 3 } [ 'd' ]  Depth  1
33.628 : DEBUG :  Not a cluster d 1
33.628 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
33.628 : INFO :  cp  d  to  D  with parent  D
33.628 : INFO :  In copy  D root D data { data: 2 } D
33.628 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
33.628 : DEBUG :  Copying Edges []
33.628 : DEBUG :  Removing node d
33.628 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.628 : DEBUG :  Done, no node has children [ 'd' ]
33.628 : DEBUG :  Done, no node has children [ 'b' ]
33.628 : DEBUG :  Done, no node has children [ 'a' ]
33.628 : INFO :  A [ 'a' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
33.637 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'd', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'b' }
  ],
  edges: [
    { v: 'a', w: 'b', name: '1', value: [Object] },
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.637 : DEBUG :  Opting in, graph 
33.637 : DEBUG :  Not a cluster  a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
33.637 : DEBUG :  Cluster identified b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
33.637 : DEBUG :  Not a cluster  c {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
33.637 : DEBUG :  Not a cluster  d {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
33.637 : DEBUG :  Not a cluster  e {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
33.637 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'd', 'e' ] 0
33.637 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true { data: 1 } undefined  Depth  0
33.637 : DEBUG :  Not a cluster a 0
33.637 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} true true { data: 2 } undefined  Depth  0
33.637 : INFO :  cp  c  to  b  with parent  b
33.637 : INFO :  In copy  b root b data { data: 2 } b
33.637 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.637 : DEBUG :  Copying Edges [
  { v: 'c', w: 'd', name: '2' },
  { v: 'd', w: 'e', name: '2' },
  { v: 'a', w: 'b', name: '1' }
]
33.637 : INFO :  Edge { v: 'c', w: 'd', name: '2' }
33.637 : INFO :  Edge data { data: 'link2' } b
33.637 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.637 : INFO :  Edge is  { v: 'c', w: 'd', name: '2' }
33.637 : INFO :  Copying as  c d { data: 'link2' } 2
33.637 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' } ] { data: 'link2' }
33.637 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
33.637 : INFO :  Edge data { data: 'link2' } b
33.637 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.637 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
33.637 : INFO :  Copying as  d e { data: 'link2' } 2
33.637 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
33.637 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
33.637 : INFO :  Edge data { data: 'link1' } b
33.637 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.637 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
33.637 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
33.637 : DEBUG :  Removing node c
33.637 : INFO :  cp  d  to  b  with parent  b
33.637 : INFO :  In copy  b root b data { data: 2 } b
33.637 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
33.637 : DEBUG :  Copying Edges [ { v: 'd', w: 'e', name: '2' }, { v: 'a', w: 'b', name: '1' } ]
33.637 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
33.637 : INFO :  Edge data { data: 'link2' } b
33.637 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.637 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
33.637 : INFO :  Copying as  d e { data: 'link2' } 2
33.637 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
33.637 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
33.637 : INFO :  Edge data { data: 'link1' } b
33.637 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.637 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
33.637 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
33.637 : DEBUG :  Removing node d
33.637 : INFO :  cp  e  to  b  with parent  b
33.637 : INFO :  In copy  b root b data { data: 2 } b
33.637 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
33.637 : DEBUG :  Copying Edges [ { v: 'a', w: 'b', name: '1' } ]
33.637 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
33.637 : INFO :  Edge data { data: 'link1' } b
33.637 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
33.637 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
33.637 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
33.637 : DEBUG :  Removing node e
33.637 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] }, { v: 'b', value: [Object] } ],
  edges: [ { v: 'a', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.637 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
33.637 : DEBUG :  Not a cluster c 0
33.637 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
33.637 : DEBUG :  Not a cluster d 0
33.637 : DEBUG :  Extracting node e {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
33.637 : DEBUG :  Not a cluster e 0
33.637 : DEBUG :  Done, no node has children [ 'c', 'd', 'e' ]
33.637 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object] },
    { v: 'd', value: [Object] },
    { v: 'e', value: [Object] }
  ],
  edges: [
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
33.638 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object], parent: 'a' },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'c' }
  ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.638 : DEBUG :  Opting in, graph 
33.638 : DEBUG :  Cluster identified a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.638 : DEBUG :  Cluster identified b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.638 : DEBUG :  Cluster identified c {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.638 : DEBUG :  Not a cluster  e {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.638 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'e' ] 0
33.638 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true { data: 1 } undefined  Depth  0
33.638 : INFO :  cp  e  to  a  with parent  c
33.638 : DEBUG :  Setting parent e c
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node e
33.638 : INFO :  cp  c  to  a  with parent  c
33.638 : INFO :  In copy  c root a data { data: 3 } a
33.638 : DEBUG :  Not Setting parent for node= c cluster!==rootId true node!==clusterId false
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node c
33.638 : DEBUG :  Removing node c
33.638 : INFO :  cp  b  to  a  with parent  b
33.638 : INFO :  In copy  b root a data { data: 2 } a
33.638 : DEBUG :  Not Setting parent for node= b cluster!==rootId true node!==clusterId false
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node b
33.638 : DEBUG :  Removing node b
33.638 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
33.638 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.638 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.638 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.638 : DEBUG :  Extracting node e {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} undefined true undefined undefined  Depth  0
33.638 : DEBUG :  Not a cluster e 0
33.638 : DEBUG :  Nodes =  [ 'e', 'c', 'b' ] 1
33.638 : DEBUG :  Extracting node e {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} undefined false { data: 3 } undefined  Depth  1
33.638 : DEBUG :  Not a cluster e 1
33.638 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true false { data: 3 } undefined  Depth  1
33.638 : INFO :  cp  e  to  c  with parent  c
33.638 : INFO :  In copy  c root c data { data: 3 } c
33.638 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node e
33.638 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'b', value: [Object] }
  ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.638 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true { data: 2 } undefined  Depth  1
33.638 : INFO :  cp  c  to  b  with parent  b
33.638 : INFO :  In copy  b root b data { data: 2 } b
33.638 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
33.638 : DEBUG :  Copying Edges []
33.638 : DEBUG :  Removing node c
33.638 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.638 : DEBUG :  Done, no node has children [ 'c' ]
33.638 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
33.641 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object], parent: 'A' },
    { v: 'b', value: [Object], parent: 'A' },
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'b', w: 'B', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.641 : DEBUG :  Opting in, graph 
33.641 : DEBUG :  Cluster identified A {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.641 : DEBUG :  Cluster identified B {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.641 : DEBUG :  Not a cluster  b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.641 : DEBUG :  Not a cluster  c {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.641 : DEBUG :  Not a cluster  a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
33.641 : DEBUG :  Nodes =  [ 'A', 'B', 'b', 'c', 'a' ] 0
33.641 : DEBUG :  Extracting node A {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  0
33.641 : INFO :  cp  c  to  A  with parent  B
33.641 : DEBUG :  Setting parent c B
33.641 : DEBUG :  Copying Edges [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ]
33.641 : INFO :  Edge { v: 'b', w: 'c', name: '1' }
33.641 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} A
33.641 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
33.641 : INFO :  Edge is  { v: 'b', w: 'c', name: '1' }
33.641 : INFO :  Copying as  b c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} 1
33.641 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
33.641 : INFO :  Edge { v: 'a', w: 'c', name: '2' }
33.641 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  classes: 'flowchart-link LS-a LE-c'
} A
33.641 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
33.641 : INFO :  Edge is  { v: 'a', w: 'c', name: '2' }
33.641 : INFO :  Copying as  a c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  classes: 'flowchart-link LS-a LE-c'
} 2
33.641 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
33.641 : DEBUG :  Removing node c
33.641 : INFO :  cp  B  to  A  with parent  B
33.641 : INFO :  In copy  B root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} A
33.641 : DEBUG :  Not Setting parent for node= B cluster!==rootId true node!==clusterId false
33.641 : DEBUG :  Copying Edges []
33.641 : DEBUG :  Removing node B
33.641 : DEBUG :  Removing node B
33.641 : INFO :  cp  b  to  A  with parent  A
33.641 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
33.641 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
33.641 : DEBUG :  Copying Edges []
33.641 : DEBUG :  Removing node b
33.641 : INFO :  cp  a  to  A  with parent  A
33.641 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
33.641 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
33.641 : DEBUG :  Copying Edges []
33.641 : DEBUG :  Removing node a
33.641 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'A', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
33.641 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} false true undefined undefined  Depth  0
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : DEBUG :  Nodes =  [ 'c', 'B', 'b', 'a' ] 1
33.641 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true false {
  labelStyle: '',
  shape: 'rect',
  labelText: 'c',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'c',
  padding: 15
} undefined  Depth  1
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} false true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  1
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'b',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'b',
  padding: 15
} undefined  Depth  1
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'a',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'a',
  padding: 15
} undefined  Depth  1
33.641 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
33.641 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'a', value: [Object] }
  ],
  edges: [
    { v: 'b', w: 'c', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

 ✓ packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js  (15 tests) 32ms
stdout | packages/mermaid/src/mermaidAPI.spec.ts > mermaidAPI > render > accessibility > gitGraph > should set aria-roledescription to the diagram type AND should call addSVGa11yTitleDescription
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, ACC_TITLE, NEWLINE> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with a node
. 
          
Lex: NODE_ID id
. 
      
Lex: EOF 
Rule: node (NODE_ID separator):  id
Rule: nodeStatement (node)  { id: 'id' }
Rule: statement:  {
  id: 'id',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a node with a square shape and a label
. 
          
Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: EOF 
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: '[]', label: 'A label' }
Rule: nodeStatement (node)  { id: 'id', label: 'A label', typeStr: '[]', directions: undefined }
Rule: statement:  {
  id: 'id',
  label: 'A label',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id',
    label: 'A label',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes
. 
          
Lex: NODE_ID id1
. 
          
Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: 'id1' }
. 
      
Lex: EOF 
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: 'id2' }
Rule: statement:  {
  id: 'id2',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id1',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id1',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id2',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes
. 
          
Lex: NODE_ID id1
. 
          
Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: 'id1' }
. 
          
Lex: NODE_ID id3
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: 'id2' }
. 
      
Lex: EOF 
Rule: node (NODE_ID separator):  id3
Rule: nodeStatement (node)  { id: 'id3' }
Rule: statement:  {
  id: 'id3',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id2',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id1',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id1',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id2',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id3',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a node with a square shape and a label
. 
          
Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: NODE_ID id2
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: '[]', label: 'A label' }
Rule: nodeStatement (node)  { id: 'id', label: 'A label', typeStr: '[]', directions: undefined }
Lex: EOF 
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: 'id2' }
Rule: statement:  {
  id: 'id2',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id',
  label: 'A label',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id',
    label: 'A label',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id2',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
. 
          
Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.   
Lex: LINK #-->   #
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: '[]', label: 'first' }
Rule: nodeStatement (node)  { id: 'id1', label: 'first', typeStr: '[]', directions: undefined }
Rule: link:  -->    -->   
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: '[]', label: 'second' }
Rule: (nodeStatement link node)  {
  id: 'id1',
  label: 'first',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
} { edgeTypeStr: '-->   ', label: '' } { id: 'id2', label: 'second', typeStr: '[]', directions: undefined }  typestr:  -->   
Rule: statement:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: '',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]
Rule: hierarchy:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: '',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
. 
          
Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.   
Lex: START_LINK -- 
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: '[]', label: 'first' }
Rule: nodeStatement (node)  { id: 'id1', label: 'first', typeStr: '[]', directions: undefined }
Lex: Starting string
LEX: STR end: a label
LEX: POPPING STR: "
Lex: LINK # -->   #
Rule: LABEL link:  --  a label  -->   
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: '[]', label: 'second' }
Rule: (nodeStatement link node)  {
  id: 'id1',
  label: 'first',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
} { edgeTypeStr: ' -->   ', label: 'a label' } { id: 'id2', label: 'second', typeStr: '[]', directions: undefined }  typestr:   -->   
Rule: statement:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: 'a label',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]
Rule: hierarchy:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: 'a label',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with column statements
. 
          
COLUMNS (LEX) 2
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '2',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 2 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 2 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram withput column statements
. 
          
Lex: NODE_ID block1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with auto column statements
. 
          
. 
          
Lex: NODE_ID block1
APA123 {
  '$': -1,
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 22 }
}
COLUMNS:  -1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: -1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: -1 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks next to each other
. 
          
COLUMNS (LEX) 2
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '2',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 2 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 2 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks on top of each other
. 
          
COLUMNS (LEX) 1
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > compound blocks 2
. 
          
Found space-block
Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
. 
            
Lex: NODE_ID bBlock
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: '[]', label: 'ABlock' }
Rule: nodeStatement (node)  { id: 'aBlock', label: 'ABlock', typeStr: '[]', directions: undefined }
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
. 
          
Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: '[]', label: 'BBlock' }
Rule: nodeStatement (node)  { id: 'bBlock', label: 'BBlock', typeStr: '[]', directions: undefined }
Rule: statement:  {
  id: 'bBlock',
  label: 'BBlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'aBlock',
  label: 'ABlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Lex: EOF 
Rule: blockStatement :  block
             [
  {
    id: 'aBlock',
    label: 'ABlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'bBlock',
    label: 'BBlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
] end
        
Rule: statement:  {
  id: 'id-rluggblprg-1',
  type: 'composite',
  label: '',
  children: [
    {
      id: 'aBlock',
      label: 'ABlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'bBlock',
      label: 'BBlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: hierarchy:  [
  {
    id: 'id-rluggblprg-1',
    type: 'composite',
    label: '',
    children: [ [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > compound blocks of compound blocks
. 
          
Found space-block
Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
. 
            
Found space-block
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: '[]', label: 'ABlock' }
Rule: nodeStatement (node)  { id: 'aBlock', label: 'ABlock', typeStr: '[]', directions: undefined }
Lex: NODE_ID bBlock
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
. 
            
Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: '[]', label: 'BBlock' }
Rule: nodeStatement (node)  { id: 'bBlock', label: 'BBlock', typeStr: '[]', directions: undefined }
Rule: statement:  {
  id: 'bBlock',
  label: 'BBlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: blockStatement :  block
               [
  {
    id: 'bBlock',
    label: 'BBlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
] end
          
Rule: statement:  {
  id: 'id-9nllq0s3f2d-2',
  type: 'composite',
  label: '',
  children: [
    {
      id: 'bBlock',
      label: 'BBlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: statement #2:  {
  id: 'aBlock',
  label: 'ABlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Lex: EOF 
Rule: blockStatement :  block
             [
  {
    id: 'aBlock',
    label: 'ABlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id-9nllq0s3f2d-2',
    type: 'composite',
    label: '',
    children: [ [Object] ]
  }
] end
        
Rule: statement:  {
  id: 'id-n4kv17m1dx-3',
  type: 'composite',
  label: '',
  children: [
    {
      id: 'aBlock',
      label: 'ABlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'id-9nllq0s3f2d-2',
      type: 'composite',
      label: '',
      children: [Array]
    }
  ]
}
Rule: hierarchy:  [
  {
    id: 'id-n4kv17m1dx-3',
    type: 'composite',
    label: '',
    children: [ [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > compound blocks with title
. 
          
Found space-block
Lex: NODE_ID compoundBlock
Lexa: [
Lex: Starting string
LEX: STR end: Compound block
LEX: POPPING STR: "
Lex: ]
. 
            
COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ Compound block ]
Rule: node (NODE_ID nodeShapeNLabel separator):  compoundBlock { typeStr: '[]', label: 'Compound block' }
Rule: nodeStatement (node)  {
  id: 'compoundBlock',
  label: 'Compound block',
  typeStr: '[]',
  directions: undefined
}
. 
            
Lex: NODE_ID block2
APA123 {
  '$': '1',
  '_$': { first_line: 3, last_line: 3, first_column: 12, last_column: 21 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
          
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Lex: EOF 
Rule: id-block statement :  {
  id: 'compoundBlock',
  label: 'Compound block',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
} [
  { type: 'column-setting', columns: 1 },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]
Rule: statement:  {
  id: 'compoundBlock',
  label: 'Compound block',
  type: 'composite',
  directions: undefined,
  widthInColumns: 1,
  children: [
    { type: 'column-setting', columns: 1 },
    {
      id: 'block2',
      label: 'Block 2',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: hierarchy:  [
  {
    id: 'compoundBlock',
    label: 'Compound block',
    type: 'composite',
    directions: undefined,
    widthInColumns: 1,
    children: [ [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks mixed with compound blocks
. 
          
COLUMNS (LEX) 1
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 

          
Found space-block
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
COLUMNS (LEX) 2
. 
            
Lex: NODE_ID block2
APA123 {
  '$': '2',
  '_$': { first_line: 6, last_line: 6, first_column: 12, last_column: 21 }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
            
Lex: NODE_ID block3
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 3
LEX: POPPING STR: "
Lex: ]
. 
          
Rule: nodeShapeNLabel:  [ Block 3 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block3 { typeStr: '[]', label: 'Block 3' }
Rule: nodeStatement (node)  {
  id: 'block3',
  label: 'Block 3',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block3',
  label: 'Block 3',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 2 }
Lex: EOF 
Rule: blockStatement :  block
             [
  { type: 'column-setting', columns: 2 },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'block3',
    label: 'Block 3',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
] end
        
Rule: statement:  {
  id: 'id-tgxgunf32bd-5',
  type: 'composite',
  label: '',
  children: [
    { type: 'column-setting', columns: 2 },
    {
      id: 'block2',
      label: 'Block 2',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'block3',
      label: 'Block 3',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id-tgxgunf32bd-5',
    type: 'composite',
    label: '',
    children: [ [Object], [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > Arrow blocks
. 
        
COLUMNS (LEX) 3
. 
        
Lex: NODE_ID block1
APA123 {
  '$': '3',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: NODE_ID blockArrow
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (right): dir: right
Lex (ARROW_DIR end): ]>
Rule: dirList:  right
Lex: NODE_ID block2
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ 'right' ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: '<[]>',
  label: '&nbsp;&nbsp;&nbsp;',
  directions: [ 'right' ]
}
Rule: nodeStatement (node)  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  typeStr: '<[]>',
  directions: [ 'right' ]
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  type: 'block_arrow',
  directions: [ 'right' ],
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 3 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'blockArrow',
    label: '&nbsp;&nbsp;&nbsp;',
    type: 'block_arrow',
    directions: [ 'right' ],
    widthInColumns: 1
  },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > Arrow blocks with multiple points
. 
        
COLUMNS (LEX) 1
. 
        
Lex: NODE_ID A
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  1
. 
        
Lex: NODE_ID blockArrow
Rule: node (NODE_ID separator):  A
Rule: nodeStatement (node)  { id: 'A' }
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (up): up
Lex (down): down
Lex (ARROW_DIR end): ]>
Rule: dirList:  down
Rule: dirList:  up [ 'down' ]
Found space-block
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ 'up', 'down' ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: '<[]>',
  label: '&nbsp;&nbsp;&nbsp;',
  directions: [ 'up', 'down' ]
}
Rule: nodeStatement (node)  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  typeStr: '<[]>',
  directions: [ 'up', 'down' ]
}
COLUMNS (LEX) 3
. 
            
Lex: NODE_ID B
APA123 {
  '$': '3',
  '_$': { first_line: 6, last_line: 6, first_column: 10, last_column: 19 }
}
COLUMNS:  3
. 
            
Lex: NODE_ID C
Rule: node (NODE_ID separator):  B
Rule: nodeStatement (node)  { id: 'B' }
. 
            
Lex: NODE_ID D
Rule: node (NODE_ID separator):  C
Rule: nodeStatement (node)  { id: 'C' }
. 
        
Rule: node (NODE_ID separator):  D
Rule: nodeStatement (node)  { id: 'D' }
Rule: statement:  {
  id: 'D',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'C',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'B',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Lex: EOF 
Rule: blockStatement :  block
           [
  { type: 'column-setting', columns: 3 },
  {
    id: 'B',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'C',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'D',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
] end
Rule: statement:  {
  id: 'id-lrn65xjdb8e-6',
  type: 'composite',
  label: '',
  children: [
    { type: 'column-setting', columns: 3 },
    {
      id: 'B',
      label: undefined,
      type: 'na',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'C',
      label: undefined,
      type: 'na',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'D',
      label: undefined,
      type: 'na',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: statement #2:  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  type: 'block_arrow',
  directions: [ 'up', 'down' ],
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'A',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'A',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'blockArrow',
    label: '&nbsp;&nbsp;&nbsp;',
    type: 'block_arrow',
    directions: [ 'up', 'down' ],
    widthInColumns: 1
  },
  {
    id: 'id-lrn65xjdb8e-6',
    type: 'composite',
    label: '',
    children: [ [Object], [Object], [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks with different widths
. 
        
COLUMNS (LEX) 3
. 
        
Lex: NODE_ID one
APA123 {
  '$': '3',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: One Slot
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: NODE_ID two
Rule: nodeShapeNLabel:  [ One Slot ]
Rule: node (NODE_ID nodeShapeNLabel separator):  one { typeStr: '[]', label: 'One Slot' }
Rule: nodeStatement (node)  { id: 'one', label: 'One Slot', typeStr: '[]', directions: undefined }
Lexa: [
Lex: Starting string
LEX: STR end: Two slots
LEX: POPPING STR: "
Lex: ]
Lex: COLON :2
Rule: nodeShapeNLabel:  [ Two slots ]
Rule: node (NODE_ID nodeShapeNLabel separator):  two { typeStr: '[]', label: 'Two slots' }
. 
        
Lex: EOF 
Rule: nodeStatement (abc88 node size)  { id: 'two', label: 'Two slots', typeStr: '[]', directions: undefined } 2
Rule: statement:  {
  id: 'two',
  label: 'Two slots',
  type: 'square',
  directions: undefined,
  widthInColumns: 2
}
Rule: statement #2:  {
  id: 'one',
  label: 'One Slot',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 3 },
  {
    id: 'one',
    label: 'One Slot',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'two',
    label: 'Two slots',
    type: 'square',
    directions: undefined,
    widthInColumns: 2
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > empty blocks
. 
        
COLUMNS (LEX) 3
. 
        
COLUMNS (LEX) 1
APA123 {
  '$': '3',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  3
. 
        
Lex: NODE_ID middle
Lexa: [
Lex: Starting string
LEX: STR end: In the middle
LEX: POPPING STR: "
Lex: ]
. 
        
COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ In the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  middle { typeStr: '[]', label: 'In the middle' }
Rule: nodeStatement (node)  {
  id: 'middle',
  label: 'In the middle',
  typeStr: '[]',
  directions: undefined
}
. 
        
Lex: EOF 
Rule: statement:  {
  id: 'id-nirlk7jfgx-8',
  type: 'space',
  label: '',
  width: 1,
  children: []
}
Rule: statement #2:  {
  id: 'middle',
  label: 'In the middle',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id-5xlvwv5blku-7',
  type: 'space',
  label: '',
  width: 1,
  children: []
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 3 },
  {
    id: 'id-5xlvwv5blku-7',
    type: 'space',
    label: '',
    width: 1,
    children: []
  },
  {
    id: 'middle',
    label: 'In the middle',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id-nirlk7jfgx-8',
    type: 'space',
    label: '',
    width: 1,
    children: []
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > classDef statements applied to a block
. 
        
. 

        
Lex: NODE_ID mc
Lexa: [
Lex: Starting string
LEX: STR end: Memcache
LEX: POPPING STR: "
Lex: ]
. 
        
Rule: nodeShapeNLabel:  [ Memcache ]
Rule: node (NODE_ID nodeShapeNLabel separator):  mc { typeStr: '[]', label: 'Memcache' }
Rule: nodeStatement (node)  { id: 'mc', label: 'Memcache', typeStr: '[]', directions: undefined }
. 
        
Lex: EOF 
Rule: statement:  { type: 'applyClass', id: 'mc', styleClass: 'black' }
Rule: statement #2:  {
  id: 'mc',
  label: 'Memcache',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'classDef', id: 'black', css: 'color:#ffffff, fill:#000000;' }
Rule: hierarchy:  [
  {
    type: 'classDef',
    id: 'black',
    css: 'color:#ffffff, fill:#000000;'
  },
  {
    id: 'mc',
    label: 'Memcache',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  { type: 'applyClass', id: 'mc', styleClass: 'black' }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > style statements applied to a block
. 

COLUMNS (LEX) 1
. 
    
Lex: NODE_ID B
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 0, last_column: 9 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: A wide one in the middle
LEX: POPPING STR: "
Lex: ]
. 
  
Rule: nodeShapeNLabel:  [ A wide one in the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  B { typeStr: '[]', label: 'A wide one in the middle' }
Rule: nodeStatement (node)  {
  id: 'B',
  label: 'A wide one in the middle',
  typeStr: '[]',
  directions: undefined
}
. 
        
Lex: EOF 
Rule: statement:  {
  type: 'applyStyles',
  id: 'B',
  stylesStr: 'fill:#f9F,stroke:#333,stroke-width:4px'
}
Rule: statement #2:  {
  id: 'B',
  label: 'A wide one in the middle',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'B',
    label: 'A wide one in the middle',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    type: 'applyStyles',
    id: 'B',
    stylesStr: 'fill:#f9F,stroke:#333,stroke-width:4px'
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a __proto__ property
. 

Lex: NODE_ID __proto__
Lex: EOF 
Rule: node (NODE_ID separator):  __proto__
Rule: nodeStatement (node)  { id: '__proto__' }
Rule: statement:  {
  id: '__proto__',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: '__proto__',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]
. 

Lex: NODE_ID A;
.  
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: 'A;' }
Lex: EOF 
Rule: statement:  {
  type: 'classDef',
  id: '__proto__',
  css: 'color:#ffffff,fill:#000000; class A __proto__'
}
Rule: statement #2:  {
  id: 'A;',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'A;',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    type: 'classDef',
    id: '__proto__',
    css: 'color:#ffffff,fill:#000000; class A __proto__'
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a constructor property
. 

Lex: NODE_ID constructor
Lex: EOF 
Rule: node (NODE_ID separator):  constructor
Rule: nodeStatement (node)  { id: 'constructor' }
Rule: statement:  {
  id: 'constructor',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'constructor',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]
. 

Lex: NODE_ID A;
.  
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: 'A;' }
Lex: EOF 
Rule: statement:  {
  type: 'classDef',
  id: 'constructor',
  css: 'color:#ffffff,fill:#000000; class A constructor'
}
Rule: statement #2:  {
  id: 'A;',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'A;',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    type: 'classDef',
    id: 'constructor',
    css: 'color:#ffffff,fill:#000000; class A constructor'
  }
]

 ✓ packages/mermaid/src/diagrams/block/parser/block.spec.ts  (24 tests) 23ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-style.spec.js  (24 tests) 24ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-singlenode.spec.js  (148 tests) 73ms
 ✓ packages/mermaid/src/diagrams/state/parser/state-style.spec.js  (15 tests) 21ms
stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-1 should handle a simple root definition abc122
34.155 : INFO :  Node:  root
34.155 : INFO :  addNode 4 root root 0
34.155 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-2 should handle a hierachial mindmap definition
34.160 : INFO :  Node:  root
34.160 : INFO :  addNode 4 root root 0
34.160 : TRACE :  Stop NL 
34.160 : INFO :  Node:  child1
34.160 : INFO :  addNode 6 child1 child1 0
34.160 : TRACE :  Stop NL 
34.160 : INFO :  Node:  child2
34.160 : INFO :  addNode 6 child2 child2 0
34.160 : TRACE :  Stop NL 
34.160 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > 3 should handle a simple root definition with a shape and without an id abc123
34.164 : TRACE :  Long description: root
34.164 : TRACE :  node end )
34.164 : TRACE :  node found .. (
34.164 : DEBUG :  In get type ( )
34.164 : INFO :  Node:  root
34.164 : INFO :  addNode 4 root root 1
34.164 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-4 should handle a deeper hierachial mindmap definition
34.165 : INFO :  Node:  root
34.165 : INFO :  addNode 4 root root 0
34.165 : TRACE :  Stop NL 
34.165 : INFO :  Node:  child1
34.165 : INFO :  addNode 6 child1 child1 0
34.165 : TRACE :  Stop NL 
34.165 : INFO :  Node:  leaf1
34.165 : INFO :  addNode 8 leaf1 leaf1 0
34.165 : TRACE :  Stop NL 
34.165 : INFO :  Node:  child2
34.165 : INFO :  addNode 6 child2 child2 0
34.165 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > 5 Multiple roots are illegal
34.167 : INFO :  Node:  root
34.167 : INFO :  addNode 4 root root 0
34.167 : TRACE :  Stop NL 
34.167 : INFO :  Node:  fakeRoot
34.167 : INFO :  addNode 4 fakeRoot fakeRoot 0

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-6 real root in wrong place
34.168 : INFO :  Node:  root
34.168 : INFO :  addNode 10 root root 0
34.168 : TRACE :  Stop NL 
34.168 : INFO :  Node:  fakeRoot
34.168 : INFO :  addNode 8 fakeRoot fakeRoot 0

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-7 should handle an id and type for a node definition
34.168 : TRACE :  Long description: The root
34.168 : TRACE :  node end ... ]
34.168 : TRACE :  node found .. root
34.168 : DEBUG :  In get type [ ]
34.168 : INFO :  Node:  root
34.168 : INFO :  addNode 4 root The root 2
34.168 : TRACE :  Stop NL 
34.168 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-8 should handle an id and type for a node definition
34.169 : INFO :  Node:  root
34.169 : INFO :  addNode 4 root root 0
34.169 : TRACE :  Stop NL 
34.169 : TRACE :  Long description: child1
34.169 : TRACE :  node end )
34.169 : TRACE :  node found .. theId
34.169 : DEBUG :  In get type ( )
34.169 : INFO :  Node:  theId
34.169 : INFO :  addNode 6 theId child1 1
34.169 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-9 should handle an id and type for a node definition
34.170 : TRACE :  Node:  root
34.170 : INFO :  addNode 0 root root 0
34.170 : TRACE :  Stop NL 
34.170 : TRACE :  Long description: child1
34.170 : TRACE :  node end )
34.170 : TRACE :  node found .. theId
34.170 : DEBUG :  In get type ( )
34.170 : INFO :  Node:  theId
34.170 : INFO :  addNode 6 theId child1 1
34.170 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-10 multiple types (circle)
34.171 : TRACE :  Long description: the root
34.171 : TRACE :  node end ))
34.171 : TRACE :  node found .. root
34.171 : DEBUG :  In get type (( ))
34.171 : INFO :  Node:  root
34.171 : INFO :  addNode 1 root the root 3
34.171 : TRACE :  Stop NL 
34.171 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-11 multiple types (cloud)
34.172 : TRACE :  Cloud Bang
34.172 : TRACE :  Long description: the root
34.172 : TRACE :  node end ((
34.172 : TRACE :  node found .. root
34.172 : DEBUG :  In get type ) (
34.172 : INFO :  Node:  root
34.172 : INFO :  addNode 1 root the root 4
34.172 : TRACE :  Stop NL 
34.172 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12 multiple types (bang)
34.172 : TRACE :  Explosion Bang
34.172 : TRACE :  Long description: the root
34.172 : TRACE :  node end ((
34.172 : TRACE :  node found .. root
34.172 : DEBUG :  In get type )) ((
34.172 : INFO :  Node:  root
34.172 : INFO :  addNode 1 root the root 5
34.172 : TRACE :  Stop NL 
34.172 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12-a multiple types (hexagon)
34.173 : TRACE :  Long description: the root
34.173 : TRACE :  node end ((
34.173 : TRACE :  node found .. root
34.173 : DEBUG :  In get type {{ }}
34.173 : INFO :  Node:  root
34.173 : INFO :  addNode 1 root the root 6
34.173 : TRACE :  Stop NL 
34.173 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-13 should be possible to set an icon for the node
34.173 : TRACE :  Long description: The root
34.173 : TRACE :  node end ... ]
34.173 : TRACE :  node found .. root
34.173 : DEBUG :  In get type [ ]
34.173 : INFO :  Node:  root
34.173 : INFO :  addNode 4 root The root 2
34.173 : TRACE :  Stop NL 
34.173 : TRACE :  Begin icon
34.173 : TRACE :  end icon
34.173 : TRACE :  Icon:  bomb
34.173 : TRACE :  Stop NL 
34.173 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-14 should be possible to set classes for the node
34.173 : TRACE :  Long description: The root
34.173 : TRACE :  node end ... ]
34.173 : TRACE :  node found .. root
34.173 : DEBUG :  In get type [ ]
34.173 : INFO :  Node:  root
34.173 : INFO :  addNode 4 root The root 2
34.173 : TRACE :  Stop NL 
34.173 : TRACE :  Stop NL 
34.173 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-15 should be possible to set both classes and icon for the node
34.174 : TRACE :  Long description: The root
34.174 : TRACE :  node end ... ]
34.174 : TRACE :  node found .. root
34.174 : DEBUG :  In get type [ ]
34.174 : INFO :  Node:  root
34.174 : INFO :  addNode 4 root The root 2
34.174 : TRACE :  Stop NL 
34.174 : TRACE :  Stop NL 
34.174 : TRACE :  Begin icon
34.174 : TRACE :  end icon
34.174 : TRACE :  Icon:  bomb
34.174 : TRACE :  Stop NL 
34.174 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-16 should be possible to set both classes and icon for the node
34.175 : TRACE :  Long description: The root
34.175 : TRACE :  node end ... ]
34.175 : TRACE :  node found .. root
34.175 : DEBUG :  In get type [ ]
34.175 : INFO :  Node:  root
34.175 : INFO :  addNode 4 root The root 2
34.175 : TRACE :  Stop NL 
34.175 : TRACE :  Begin icon
34.175 : TRACE :  end icon
34.175 : TRACE :  Icon:  bomb
34.175 : TRACE :  Stop NL 
34.175 : TRACE :  Stop NL 
34.175 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-17 should be possible to use node syntax in the descriptions
34.177 : TRACE :  Starting NSTR
34.177 : TRACE :  description: String containing []
34.177 : TRACE :  node end ... ]
34.177 : TRACE :  node found .. root
34.177 : DEBUG :  In get type [ ]
34.177 : INFO :  Node:  root
34.177 : INFO :  addNode 4 root String containing [] 2
34.177 : TRACE :  Stop NL 
34.177 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-18 should be possible to use node syntax in the descriptions in children
34.183 : TRACE :  Starting NSTR
34.183 : TRACE :  description: String containing []
34.183 : TRACE :  node end ... ]
34.183 : TRACE :  node found .. root
34.183 : DEBUG :  In get type [ ]
34.183 : INFO :  Node:  root
34.183 : INFO :  addNode 4 root String containing [] 2
34.183 : TRACE :  Stop NL 
34.183 : TRACE :  Starting NSTR
34.183 : TRACE :  description: String containing ()
34.183 : TRACE :  node end ... ]
34.183 : TRACE :  node found .. child1
34.183 : DEBUG :  In get type [ ]
34.183 : INFO :  Node:  child1
34.183 : INFO :  addNode 6 child1 String containing () 2
34.183 : TRACE :  Stop NL 
34.183 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-19 should be possible to have a child after a class assignment
34.184 : TRACE :  Long description: Root
34.184 : TRACE :  node end )
34.184 : TRACE :  node found .. root
34.184 : DEBUG :  In get type ( )
34.184 : INFO :  Node:  root
34.184 : INFO :  addNode 2 root Root 1
34.184 : TRACE :  Stop NL 
34.184 : TRACE :  Long description: Child
34.184 : TRACE :  node end )
34.184 : TRACE :  node found .. Child
34.184 : DEBUG :  In get type ( )
34.184 : INFO :  Node:  Child
34.184 : INFO :  addNode 4 Child Child 1
34.184 : TRACE :  Stop NL 
34.184 : TRACE :  Stop NL 
34.184 : TRACE :  Long description: a
34.184 : TRACE :  node end )
34.184 : TRACE :  node found .. a
34.184 : DEBUG :  In get type ( )
34.184 : INFO :  Node:  a
34.184 : INFO :  addNode 6 a a 1
34.184 : TRACE :  Stop NL 
34.184 : TRACE :  Long description: New Stuff
34.184 : TRACE :  node end ... ]
34.184 : TRACE :  node found .. b
34.184 : DEBUG :  In get type [ ]
34.184 : INFO :  Node:  b
34.184 : INFO :  addNode 6 b New Stuff 2
34.184 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-20 should be possible to have meaningless empty rows in a mindmap abc124
34.185 : TRACE :  Long description: Root
34.185 : TRACE :  node end )
34.185 : TRACE :  node found .. root
34.185 : DEBUG :  In get type ( )
34.185 : INFO :  Node:  root
34.185 : INFO :  addNode 2 root Root 1
34.185 : TRACE :  Stop NL 
34.185 : TRACE :  Long description: Child
34.185 : TRACE :  node end )
34.185 : TRACE :  node found .. Child
34.185 : DEBUG :  In get type ( )
34.185 : INFO :  Node:  Child
34.185 : INFO :  addNode 4 Child Child 1
34.185 : TRACE :  Stop NL 
34.185 : TRACE :  Long description: a
34.185 : TRACE :  node end )
34.185 : TRACE :  SPACELINE
34.185 : TRACE :  node found .. a
34.185 : DEBUG :  In get type ( )
34.185 : INFO :  Node:  a
34.185 : INFO :  addNode 6 a a 1
34.185 : TRACE :  Long description: New Stuff
34.185 : TRACE :  node end ... ]
34.185 : TRACE :  node found .. b
34.185 : DEBUG :  In get type [ ]
34.185 : INFO :  Node:  b
34.185 : INFO :  addNode 6 b New Stuff 2
34.185 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-21 should be possible to have comments in a mindmap
34.186 : TRACE :  Long description: Root
34.186 : TRACE :  node end )
34.186 : TRACE :  node found .. root
34.186 : DEBUG :  In get type ( )
34.186 : INFO :  Node:  root
34.186 : INFO :  addNode 2 root Root 1
34.186 : TRACE :  Stop NL 
34.186 : TRACE :  Long description: Child
34.186 : TRACE :  node end )
34.186 : TRACE :  node found .. Child
34.186 : DEBUG :  In get type ( )
34.186 : INFO :  Node:  Child
34.186 : INFO :  addNode 4 Child Child 1
34.186 : TRACE :  Stop NL 
34.186 : TRACE :  Long description: a
34.186 : TRACE :  node end )
34.186 : TRACE :  Found comment 

      %% This is a comment
34.186 : TRACE :  node found .. a
34.186 : DEBUG :  In get type ( )
34.186 : INFO :  Node:  a
34.186 : INFO :  addNode 6 a a 1
34.186 : TRACE :  Stop NL2 
34.186 : TRACE :  Long description: New Stuff
34.186 : TRACE :  node end ... ]
34.186 : TRACE :  node found .. b
34.186 : DEBUG :  In get type [ ]
34.186 : INFO :  Node:  b
34.186 : INFO :  addNode 6 b New Stuff 2
34.186 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-22 should be possible to have comments at the end of a line
34.186 : TRACE :  Long description: Root
34.186 : TRACE :  node end )
34.186 : TRACE :  node found .. root
34.186 : DEBUG :  In get type ( )
34.186 : INFO :  Node:  root
34.186 : INFO :  addNode 2 root Root 1
34.186 : TRACE :  Stop NL 
34.186 : TRACE :  Long description: Child
34.186 : TRACE :  node end )
34.186 : TRACE :  node found .. Child
34.186 : DEBUG :  In get type ( )
34.186 : INFO :  Node:  Child
34.186 : INFO :  addNode 4 Child Child 1
34.186 : TRACE :  Stop NL 
34.186 : TRACE :  Long description: a
34.186 : TRACE :  node end )
34.186 : TRACE :  Found comment  %% This is a comment
34.186 : TRACE :  node found .. a
34.186 : DEBUG :  In get type ( )
34.186 : INFO :  Node:  a
34.186 : INFO :  addNode 6 a a 1
34.186 : TRACE :  Stop NL2 
34.186 : TRACE :  Long description: New Stuff
34.186 : TRACE :  node end ... ]
34.186 : TRACE :  node found .. b
34.186 : DEBUG :  In get type [ ]
34.186 : INFO :  Node:  b
34.186 : INFO :  addNode 6 b New Stuff 2
34.186 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-23 Rows with only spaces should not interfere
34.187 : TRACE :  Node:  root
34.187 : INFO :  addNode 0 root root 0
34.187 : TRACE :  Stop NL 
34.187 : TRACE :  SPACELINE
34.187 : INFO :  Node:  A
34.187 : INFO :  addNode 1 A A 0
34.187 : INFO :  Node:  B
34.187 : INFO :  addNode 1 B B 0
34.187 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-24 Handle rows above the mindmap declarations
34.188 : TRACE :  SPACELINE
34.188 : TRACE :  Node:  root
34.188 : INFO :  addNode 0 root root 0
34.188 : TRACE :  Stop NL 
34.188 : TRACE :  SPACELINE
34.188 : INFO :  Node:  A
34.188 : INFO :  addNode 1 A A 0
34.188 : INFO :  Node:  B
34.188 : INFO :  addNode 1 B B 0
34.188 : TRACE :  Stop EOF 

 ✓ packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts  (26 tests) 35ms
stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-25 Handle rows above the mindmap declarations, no space
34.188 : TRACE :  SPACELINE
34.188 : TRACE :  Node:  root
34.188 : INFO :  addNode 0 root root 0
34.188 : TRACE :  Stop NL 
34.188 : TRACE :  SPACELINE
34.188 : INFO :  Node:  A
34.188 : INFO :  addNode 1 A A 0
34.188 : INFO :  Node:  B
34.188 : INFO :  addNode 1 B B 0
34.188 : TRACE :  Stop EOF 

 ✓ packages/mermaid/src/mermaidAPI.spec.ts  (76 tests) 1246ms
 ✓ packages/mermaid/src/diagrams/state/stateDiagram-v2.spec.js  (29 tests) 31ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-node-data.spec.js  (24 tests) 24ms
 ✓ packages/mermaid/src/diagrams/state/stateDiagram.spec.js  (29 tests | 1 skipped) 13ms
 ✓ packages/mermaid/src/accessibility.spec.ts  (20 tests) 10ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/subgraph.spec.js  (22 tests | 1 skipped) 15ms
 ✓ packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js  (27 tests) 37ms
 ✓ packages/mermaid/src/rendering-util/handle-markdown-text.spec.ts  (19 tests) 21ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-arrows.spec.js  (14 tests) 18ms
 ✓ packages/mermaid/src/rendering-util/rendering-elements/nodes.spec.ts  (39 tests) 3ms
 ✓ packages/mermaid/src/utils/lineWithOffset.ts  (2 tests) 5ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-vertice-chaining.spec.js  (7 tests) 12ms
 ✓ packages/parser/tests/gitGraph.test.ts  (26 tests) 19ms
 ✓ packages/mermaid/src/rendering-util/splitText.spec.ts  (35 tests) 15ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow.spec.js  (25 tests) 61ms
 ✓ packages/mermaid/src/diagrams/git/gitGraphParser.ts  (6 tests) 4ms
 ✓ packages/mermaid/src/diagrams/sequence/svgDraw.spec.js  (6 tests) 21ms
 ✓ packages/parser/tests/pie.test.ts  (31 tests) 24ms
 ✓ packages/mermaid/src/mermaid.spec.ts  (13 tests) 642ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-interactions.spec.js  (13 tests) 15ms
 ✓ packages/mermaid/src/diagrams/state/parser/state-parser.spec.js  (9 tests) 19ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-comments.spec.js  (9 tests) 7ms
 ✓ packages/mermaid/src/diagrams/user-journey/parser/journey.spec.js  (7 tests) 10ms
 ✓ packages/mermaid/src/diagram-api/frontmatter.spec.ts  (12 tests) 14ms
 ✓ packages/mermaid/src/diagrams/pie/pie.spec.ts  (14 tests | 2 skipped) 41ms
 ✓ packages/mermaid/src/diagrams/timeline/timeline.spec.js  (7 tests) 10ms
 ✓ packages/mermaid/src/diagrams/packet/packet.spec.ts  (9 tests) 49ms
 ✓ packages/mermaid/src/diagrams/flowchart/flowChartShapes.spec.js  (11 tests) 6ms
 ✓ packages/mermaid/src/diagrams/class/classDiagram-styles.spec.js  (10 tests) 13ms
 ✓ packages/mermaid/src/styles.spec.ts  (76 tests) 445ms
 ✓ packages/mermaid/src/docs/.vitepress/theme/redirect.spec.ts  (28 tests) 9ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Container.spec.js  (48 tests) 31ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-lines.spec.js  (9 tests) 14ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4System.spec.js  (42 tests) 25ms
 ✓ packages/mermaid/src/diagram.spec.ts  (6 tests) 222ms
 ✓ packages/mermaid/src/diagram-api/diagram-orchestration.spec.ts  (23 tests) 7ms
 ✓ packages/mermaid/src/diagrams/common/common.spec.ts  (20 tests) 22ms
 ✓ packages/mermaid/src/config.spec.ts  (5 tests) 12ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4PersonExt.spec.js  (7 tests) 9ms
 ✓ packages/mermaid/src/rendering-util/rendering-elements/edgeMarker.spec.ts  (5 tests) 6ms
 ✓ packages/mermaid/src/dagre-wrapper/edgeMarker.spec.ts  (5 tests) 4ms
 ✓ packages/mermaid/src/diagrams/user-journey/journeyDb.spec.js  (9 tests) 6ms
 ✓ packages/mermaid/src/diagrams/state/stateDb.spec.js  (5 tests) 18ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Person.spec.js  (7 tests) 9ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Boundary.spec.js  (6 tests) 15ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-direction.spec.js  (4 tests) 11ms
 ✓ packages/mermaid/src/diagrams/quadrant-chart/quadrantDb.spec.ts  (4 tests) 3ms
stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 1 - intersection on left edge of box
38.382 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":31,"y":143.2257070163421}
  insidePoint : {"x":99.3359375,"y":100}
  node        : x:171 y:100 w:210 h:184
38.382 : DEBUG :  sides calc abc89, Q 43.22570701634211, q 22.139152558958802, R 68.3359375, r 35 { _x: 66, _y: 122.1391525589588 }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 2 - intersection on left edge of box
38.383 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":310.2578125,"y":169.88002060631462}
  insidePoint : {"x":127.96875,"y":100}
  node        : x:100.23046875 y:176.75 w:184.4609375 h:337.5
38.383 : DEBUG :  sides calc abc89, Q 69.88002060631462, q 45.15711441743504, R 182.2890625, r 117.796875 { _x: 192.4609375, _y: 145.15711441743503 }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 3 - intersection on top of box outside point greater then inside point
38.384 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":157,"y":39}
  insidePoint : {"x":104,"y":105}
  node        : x:114 y:164 w:212 h:176
38.384 : DEBUG :  abc89 topp/bott calc, Q 66, q 37, R 53, r 29.71212121212121 { x: 133.71212121212122, y: 76 }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 4 - intersection on top of box inside point greater then inside point
38.384 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":144,"y":38}
  insidePoint : {"x":198,"y":105}
  node        : x:114 y:164 w:212 h:176
38.384 : DEBUG :  abc89 topp/bott calc, Q 67, q 38, R 54, r 30.62686567164179 { x: 174.62686567164178, y: 76 }

 ✓ packages/mermaid/src/dagre-wrapper/edges.spec.js  (4 tests) 4ms
 ✓ packages/mermaid/src/diagram-api/comments.spec.ts  (5 tests) 4ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-md-string.spec.js  (2 tests) 8ms
 ✓ packages/mermaid/src/diagrams/flowchart/flowDb.spec.ts  (7 tests) 7ms
 ✓ packages/mermaid/src/diagram-api/diagramAPI.spec.ts  (3 tests) 32ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Diagram.spec.js  (3 tests) 9ms
 ✓ packages/mermaid/src/utils/imperativeState.spec.ts  (3 tests) 2ms
 ❯ packages/mermaid/src/diagrams/sankey/parser/sankey.spec.ts  (0 test)
 ✓ packages/mermaid/src/rendering-util/createText.spec.ts  (4 tests) 5ms
 ✓ packages/mermaid/src/diagrams/info/info.spec.ts  (4 tests) 35ms
 ✓ packages/parser/tests/info.test.ts  (12 tests) 7ms
 ✓ packages/mermaid-example-diagram/src/exampleDiagram.spec.js  (1 test) 2ms
 ✓ packages/mermaid/src/diagrams/class/svgDraw.spec.js  (2 tests) 1ms
 ✓ packages/mermaid/src/setupGraphViewbox.spec.js  (2 tests) 1ms
 ✓ packages/mermaid/src/utils/subGraphTitleMargins.spec.ts  (1 test) 3ms
 ↓ packages/mermaid/src/diagrams/flowchart/parser/flow-huge.spec.js  (1 test | 1 skipped)
 ✓ |@mermaid-js/docs| .vitepress/theme/redirect.spec.ts  (28 tests) 4ms
 ✓ packages/mermaid/src/diagrams/block/layout.spec.ts  (1 test) 1ms
 ✓ packages/mermaid/src/diagrams/class/parser/class.spec.js  (2 tests) 6ms
 ✓ packages/mermaid/src/diagrams/er/erRenderer.spec.ts  (1 test) 1ms

 Test Files  2 failed | 86 passed | 1 skipped (89)
      Tests  3262 passed | 10 skipped | 2 todo (3274)
   Start at  19:48:26
   Duration  9.09s (transform 4.46s, setup 788ms, collect 19.51s, tests 5.31s, environment 22.02s, prepare 5.84s)

 ELIFECYCLE  Command failed with exit code 1.
