
> mermaid-monorepo@10.2.4 ci /Users/kamalsalah/Desktop/Thesis/finalEvaluation/evaluation/mermaid
> vitest run


 RUN  v1.6.0 /Users/kamalsalah/Desktop/Thesis/finalEvaluation/evaluation/mermaid

 ✓ packages/mermaid/src/diagrams/class/classTypes.spec.ts  (93 tests) 23ms
 ✓ packages/mermaid/src/diagrams/git/gitGraphRenderer.ts  (30 tests) 8ms
 ✓ packages/mermaid/src/diagrams/er/parser/erDiagram.spec.js  (596 tests | 1 skipped) 79ms
stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing basic gitGraph > should handle a gitGraph definition
Ambiguous Alternatives Detected: <0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, commit, NEWLINE> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing basic gitGraph > should checkout a branch
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, branch, ID> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing more advanced gitGraphs > should throw error when trying to merge, when current branch has no commits
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, merge, ID> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

stdout | packages/mermaid/src/diagrams/git/gitGraph.spec.ts > when parsing a gitGraph > when parsing more advanced gitGraphs > accessibility > should handle a title and a description (accDescr)
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, ACC_TITLE, NEWLINE> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

 ✓ packages/mermaid/src/diagrams/git/gitGraph.spec.ts  (68 tests | 4 skipped) 101ms
 ✓ packages/mermaid/src/diagrams/class/classDiagram.spec.ts  (367 tests | 1 skipped) 413ms
 ✓ packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts  (43 tests | 1 skipped) 14ms
 ✓ packages/mermaid/src/diagrams/sequence/sequenceDiagram.spec.js  (101 tests) 403ms
 ✓ packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.spec.js  (29 tests) 14ms
 ✓ packages/mermaid/src/diagrams/xychart/parser/xychart.jison.spec.ts  (48 tests) 28ms
 ✓ packages/mermaid/src/utils.spec.ts  (53 tests) 15ms
 ✓ packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison.spec.ts  (14 tests) 26ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-text.spec.js  (342 tests) 138ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-1 should handle a simple root definition abc122
34.908 : INFO :  Node:  root
34.908 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-2 should handle a hierachial kanban definition
34.910 : INFO :  Node:  root
34.910 : TRACE :  Stop NL 
34.910 : INFO :  Node:  child1
34.910 : TRACE :  Stop NL 
34.910 : INFO :  Node:  child2
34.910 : TRACE :  Stop NL 
34.910 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > 3 should handle a simple root definition with a shape and without an id abc123
34.914 : TRACE :  Long description: root
34.914 : TRACE :  node end )
34.914 : TRACE :  node found .. (
34.914 : DEBUG :  In get type ( )
34.914 : INFO :  Node:  root
34.914 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-4 should not dsitinguis between deeper hierachial levels in thr kanban definition
34.914 : INFO :  Node:  root
34.914 : TRACE :  Stop NL 
34.914 : INFO :  Node:  child1
34.914 : TRACE :  Stop NL 
34.914 : INFO :  Node:  leaf1
34.914 : TRACE :  Stop NL 
34.914 : INFO :  Node:  child2
34.914 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > 5 Multiple sections are ok
34.917 : INFO :  Node:  section1
34.917 : TRACE :  Stop NL 
34.917 : INFO :  Node:  section2
34.917 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hiearchy > KNBN-6 real root in wrong place
34.918 : INFO :  Node:  root
34.918 : TRACE :  Stop NL 
34.918 : INFO :  Node:  fakeRoot
34.918 : TRACE :  Stop NL 
34.918 : INFO :  Node:  realRootWrongPlace

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-7 should handle an id and type for a node definition
34.919 : TRACE :  Long description: The root
34.919 : TRACE :  node end ... ]
34.919 : TRACE :  node found .. root
34.919 : DEBUG :  In get type [ ]
34.919 : INFO :  Node:  root
34.919 : TRACE :  Stop NL 
34.919 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-8 should handle an id and type for a node definition
34.920 : INFO :  Node:  root
34.920 : TRACE :  Stop NL 
34.920 : TRACE :  Long description: child1
34.920 : TRACE :  node end )
34.920 : TRACE :  node found .. theId
34.920 : DEBUG :  In get type ( )
34.920 : INFO :  Node:  theId
34.920 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-9 should handle an id and type for a node definition
34.922 : TRACE :  Node:  root
34.922 : TRACE :  Stop NL 
34.922 : TRACE :  Long description: child1
34.922 : TRACE :  node end )
34.922 : TRACE :  node found .. theId
34.922 : DEBUG :  In get type ( )
34.922 : INFO :  Node:  theId
34.922 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-13 should be possible to set an icon for the node
34.923 : TRACE :  Long description: The root
34.923 : TRACE :  node end ... ]
34.923 : TRACE :  node found .. root
34.923 : DEBUG :  In get type [ ]
34.923 : INFO :  Node:  root
34.923 : TRACE :  Stop NL 
34.923 : TRACE :  Begin icon
34.923 : TRACE :  end icon
34.923 : TRACE :  Icon:  bomb
34.923 : TRACE :  Stop NL 
34.923 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-14 should be possible to set classes for the node
34.924 : TRACE :  Long description: The root
34.924 : TRACE :  node end ... ]
34.924 : TRACE :  node found .. root
34.924 : DEBUG :  In get type [ ]
34.924 : INFO :  Node:  root
34.924 : TRACE :  Stop NL 
34.924 : TRACE :  Stop NL 
34.924 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-15 should be possible to set both classes and icon for the node
34.925 : TRACE :  Long description: The root
34.925 : TRACE :  node end ... ]
34.925 : TRACE :  node found .. root
34.925 : DEBUG :  In get type [ ]
34.925 : INFO :  Node:  root
34.925 : TRACE :  Stop NL 
34.925 : TRACE :  Stop NL 
34.925 : TRACE :  Begin icon
34.925 : TRACE :  end icon
34.925 : TRACE :  Icon:  bomb
34.925 : TRACE :  Stop NL 
34.925 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-16 should be possible to set both classes and icon for the node
34.925 : TRACE :  Long description: The root
34.925 : TRACE :  node end ... ]
34.925 : TRACE :  node found .. root
34.925 : DEBUG :  In get type [ ]
34.925 : INFO :  Node:  root
34.925 : TRACE :  Stop NL 
34.925 : TRACE :  Begin icon
34.925 : TRACE :  end icon
34.925 : TRACE :  Icon:  bomb
34.925 : TRACE :  Stop NL 
34.925 : TRACE :  Stop NL 
34.925 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-17 should be possible to use node syntax in the descriptions
34.930 : TRACE :  Starting NSTR
34.930 : TRACE :  description: String containing []
34.930 : TRACE :  node end ... ]
34.930 : TRACE :  node found .. root
34.930 : DEBUG :  In get type [ ]
34.930 : INFO :  Node:  root
34.930 : TRACE :  Stop NL 
34.930 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-18 should be possible to use node syntax in the descriptions in children
34.930 : TRACE :  Starting NSTR
34.930 : TRACE :  description: String containing []
34.930 : TRACE :  node end ... ]
34.930 : TRACE :  node found .. root
34.930 : DEBUG :  In get type [ ]
34.930 : INFO :  Node:  root
34.930 : TRACE :  Stop NL 
34.930 : TRACE :  Starting NSTR
34.930 : TRACE :  description: String containing ()
34.930 : TRACE :  node end ... ]
34.930 : TRACE :  node found .. child1
34.930 : DEBUG :  In get type [ ]
34.930 : INFO :  Node:  child1
34.930 : TRACE :  Stop NL 
34.930 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-19 should be possible to have a child after a class assignment
34.930 : TRACE :  Long description: Root
34.930 : TRACE :  node end )
34.930 : TRACE :  node found .. root
34.930 : DEBUG :  In get type ( )
34.930 : INFO :  Node:  root
34.930 : TRACE :  Stop NL 
34.930 : TRACE :  Long description: Child
34.930 : TRACE :  node end )
34.930 : TRACE :  node found .. Child
34.930 : DEBUG :  In get type ( )
34.930 : INFO :  Node:  Child
34.930 : TRACE :  Stop NL 
34.930 : TRACE :  Stop NL 
34.930 : TRACE :  Long description: a
34.930 : TRACE :  node end )
34.930 : TRACE :  node found .. a
34.930 : DEBUG :  In get type ( )
34.930 : INFO :  Node:  a
34.930 : TRACE :  Stop NL 
34.930 : TRACE :  Long description: New Stuff
34.930 : TRACE :  node end ... ]
34.930 : TRACE :  node found .. b
34.930 : DEBUG :  In get type [ ]
34.930 : INFO :  Node:  b
34.930 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-20 should be possible to have meaningless empty rows in a kanban abc124
34.931 : TRACE :  Long description: Root
34.931 : TRACE :  node end )
34.931 : TRACE :  node found .. root
34.931 : DEBUG :  In get type ( )
34.931 : INFO :  Node:  root
34.931 : TRACE :  Stop NL 
34.931 : TRACE :  Long description: Child
34.931 : TRACE :  node end )
34.931 : TRACE :  node found .. Child
34.931 : DEBUG :  In get type ( )
34.931 : INFO :  Node:  Child
34.931 : TRACE :  Stop NL 
34.931 : TRACE :  Long description: a
34.931 : TRACE :  node end )
34.931 : TRACE :  SPACELINE
34.931 : TRACE :  node found .. a
34.931 : DEBUG :  In get type ( )
34.931 : INFO :  Node:  a
34.931 : TRACE :  Long description: New Stuff
34.931 : TRACE :  node end ... ]
34.931 : TRACE :  node found .. b
34.931 : DEBUG :  In get type [ ]
34.931 : INFO :  Node:  b
34.931 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-21 should be possible to have comments in a kanban
34.933 : TRACE :  Long description: Root
34.933 : TRACE :  node end )
34.933 : TRACE :  node found .. root
34.933 : DEBUG :  In get type ( )
34.933 : INFO :  Node:  root
34.933 : TRACE :  Stop NL 
34.933 : TRACE :  Long description: Child
34.933 : TRACE :  node end )
34.933 : TRACE :  node found .. Child
34.933 : DEBUG :  In get type ( )
34.933 : INFO :  Node:  Child
34.933 : TRACE :  Stop NL 
34.933 : TRACE :  Long description: a
34.933 : TRACE :  node end )
34.933 : TRACE :  Found comment 

      %% This is a comment
34.933 : TRACE :  node found .. a
34.933 : DEBUG :  In get type ( )
34.933 : INFO :  Node:  a
34.933 : TRACE :  Stop NL2 
34.933 : TRACE :  Long description: New Stuff
34.933 : TRACE :  node end ... ]
34.933 : TRACE :  node found .. b
34.933 : DEBUG :  In get type [ ]
34.933 : INFO :  Node:  b
34.933 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-22 should be possible to have comments at the end of a line
34.934 : TRACE :  Long description: Root
34.934 : TRACE :  node end )
34.934 : TRACE :  node found .. root
34.934 : DEBUG :  In get type ( )
34.934 : INFO :  Node:  root
34.934 : TRACE :  Stop NL 
34.934 : TRACE :  Long description: Child
34.934 : TRACE :  node end )
34.934 : TRACE :  node found .. Child
34.934 : DEBUG :  In get type ( )
34.934 : INFO :  Node:  Child
34.934 : TRACE :  Stop NL 
34.934 : TRACE :  Long description: a
34.934 : TRACE :  node end )
34.934 : TRACE :  Found comment  %% This is a comment
34.934 : TRACE :  node found .. a
34.934 : DEBUG :  In get type ( )
34.934 : INFO :  Node:  a
34.934 : TRACE :  Stop NL2 
34.934 : TRACE :  Long description: New Stuff
34.934 : TRACE :  node end ... ]
34.934 : TRACE :  node found .. b
34.934 : DEBUG :  In get type [ ]
34.934 : INFO :  Node:  b
34.934 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-23 Rows with only spaces should not interfere
34.935 : TRACE :  Node:  root
34.935 : TRACE :  Stop NL 
34.935 : TRACE :  SPACELINE
34.935 : INFO :  Node:  A
34.935 : INFO :  Node:  B
34.935 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-24 Handle rows above the kanban declarations
34.935 : TRACE :  SPACELINE
34.935 : TRACE :  Node:  root
34.935 : TRACE :  Stop NL 
34.935 : TRACE :  SPACELINE
34.935 : INFO :  Node:  A
34.935 : INFO :  Node:  B
34.935 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-25 Handle rows above the kanban declarations, no space
34.936 : TRACE :  SPACELINE
34.936 : TRACE :  Node:  root
34.936 : TRACE :  Stop NL 
34.936 : TRACE :  SPACELINE
34.936 : INFO :  Node:  A
34.936 : INFO :  Node:  B
34.936 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-30 should be possible to set the priority
34.937 : INFO :  Node:  root
34.937 : TRACE :  Stop NL 
34.937 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-31 should be possible to set the assignment
34.938 : INFO :  Node:  root
34.938 : TRACE :  Stop NL 
34.938 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-32 should be possible to set the icon
34.938 : INFO :  Node:  root
34.938 : TRACE :  Stop NL 
34.938 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-33 should be possible to set the icon
34.939 : INFO :  Node:  root
34.939 : TRACE :  Stop NL 
34.939 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-34 should be possible to set the metadata using multiple lines
34.939 : INFO :  Node:  root
34.939 : TRACE :  Stop NL 
34.939 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-35 should be possible to set the metadata using one line
34.939 : INFO :  Node:  root
34.939 : TRACE :  Stop NL 
34.939 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-36 should be possible to set the label using the new syntax
34.940 : INFO :  Node:  root
34.940 : TRACE :  Stop NL 
34.940 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-37 should be possible to set the external id
34.940 : INFO :  Node:  root
34.940 : TRACE :  Stop NL 
34.940 : TRACE :  Stop EOF 

 ✓ packages/mermaid/src/diagrams/kanban/kanban.spec.ts  (30 tests) 34ms
 ❯ packages/mermaid/scripts/docs.spec.ts  (0 test)
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-edges.spec.js  (247 tests) 122ms
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
35.283 : DEBUG :  Opting in, graph 
35.283 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
35.283 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
35.283 : DEBUG :  Not a cluster  c Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
35.283 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
35.283 : DEBUG :  Cluster identified C2 Map(2) { 'C1' => [ 'a', 'b' ], 'C2' => [ 'c' ] }
35.283 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
35.283 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} false false {} undefined  Depth  0
35.283 : DEBUG :  Not a cluster a 0
35.283 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} false false {} undefined  Depth  0
35.283 : DEBUG :  Not a cluster b 0
35.283 : DEBUG :  Extracting node c Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} false false {} undefined  Depth  0
35.283 : DEBUG :  Not a cluster c 0
35.283 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.283 : INFO :  cp  a  to  C1  with parent  C1
35.283 : INFO :  In copy  C1 root C1 data undefined C1
35.283 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.283 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'C2' } ]
35.283 : INFO :  Edge { v: 'a', w: 'b' }
35.283 : INFO :  Edge data {} C1
35.283 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
35.283 : INFO :  Edge is  { v: 'a', w: 'b' }
35.283 : INFO :  Copying as  a b {} undefined
35.283 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] {}
35.283 : INFO :  Edge { v: 'C1', w: 'C2' }
35.283 : INFO :  Edge data {} C1
35.283 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
35.283 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.283 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
35.283 : DEBUG :  Removing node a
35.283 : INFO :  cp  b  to  C1  with parent  C1
35.283 : INFO :  In copy  C1 root C1 data undefined C1
35.283 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.283 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.283 : INFO :  Edge { v: 'C1', w: 'C2' }
35.283 : INFO :  Edge data {} C1
35.283 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
35.283 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.283 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
35.283 : DEBUG :  Removing node b
35.283 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: {}, parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.283 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.283 : INFO :  cp  c  to  C2  with parent  C2
35.283 : INFO :  In copy  C2 root C2 data undefined C2
35.283 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.283 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.283 : INFO :  Edge { v: 'C1', w: 'C2' }
35.283 : INFO :  Edge data {} C2
35.283 : INFO :  Descendants of  C2  is  [ 'c' ]
35.283 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.283 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
35.283 : DEBUG :  Removing node c
35.283 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.283 : DEBUG :  Done, no node has children [ 'a', 'b' ]
35.283 : DEBUG :  Done, no node has children [ 'c' ]
35.283 : INFO :  [ { v: 'C1', w: 'C2' } ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
35.288 : DEBUG :  Opting in, graph 
35.288 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
35.288 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
35.288 : DEBUG :  Not a cluster  c Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
35.288 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
35.288 : DEBUG :  Cluster identified C2 Map(2) { 'C1' => [ 'b', 'C2', 'a' ], 'C2' => [ 'a' ] }
35.288 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
35.288 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false false { data: 1 } undefined  Depth  0
35.288 : DEBUG :  Not a cluster a 0
35.288 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false false { data: 2 } undefined  Depth  0
35.288 : DEBUG :  Not a cluster b 0
35.288 : DEBUG :  Extracting node c Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 3 } undefined  Depth  0
35.288 : DEBUG :  Not a cluster c 0
35.288 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} true true { data: 4 } undefined  Depth  0
35.288 : INFO :  cp  b  to  C1  with parent  C1
35.288 : INFO :  In copy  C1 root C1 data { data: 4 } C1
35.288 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.288 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'c' } ]
35.288 : INFO :  Edge { v: 'a', w: 'b' }
35.288 : INFO :  Edge data { name: 'C1-internal-link' } C1
35.288 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.288 : INFO :  Edge is  { v: 'a', w: 'b' }
35.288 : INFO :  Copying as  a b { name: 'C1-internal-link' } undefined
35.288 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] { name: 'C1-internal-link' }
35.288 : INFO :  Edge { v: 'C1', w: 'c' }
35.288 : INFO :  Edge data { name: 'C1-external-link' } C1
35.288 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.288 : INFO :  Edge is  { v: 'C1', w: 'c' }
35.288 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
35.288 : DEBUG :  Removing node b
35.288 : INFO :  cp  a  to  C1  with parent  C2
35.288 : DEBUG :  Setting parent a C2
35.288 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
35.288 : INFO :  Edge { v: 'C1', w: 'c' }
35.288 : INFO :  Edge data { name: 'C1-external-link' } C1
35.288 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.288 : INFO :  Edge is  { v: 'C1', w: 'c' }
35.288 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
35.288 : DEBUG :  Removing node a
35.288 : INFO :  cp  C2  to  C1  with parent  C2
35.288 : INFO :  In copy  C2 root C1 data { data: 5 } C1
35.288 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId true node!==clusterId false
35.288 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
35.288 : INFO :  Edge { v: 'C1', w: 'c' }
35.288 : INFO :  Edge data { name: 'C1-external-link' } C1
35.288 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.288 : INFO :  Edge is  { v: 'C1', w: 'c' }
35.288 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
35.288 : DEBUG :  Removing node C2
35.288 : DEBUG :  Removing node C2
35.288 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'c', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'c', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.288 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true undefined undefined  Depth  0
35.288 : DEBUG :  Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
35.288 : DEBUG :  Nodes =  [ 'b', 'a', 'C2' ] 1
35.288 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 2 } undefined  Depth  1
35.288 : DEBUG :  Not a cluster b 1
35.288 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false false { data: 1 } undefined  Depth  1
35.288 : DEBUG :  Not a cluster a 1
35.288 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 5 } undefined  Depth  1
35.288 : DEBUG :  Map(2) {
  'C1' => { id: 'b', clusterData: { data: 4 } },
  'C2' => { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
35.288 : INFO :  [ 'c', 'C1' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
35.290 : INFO :  [ 'a', 'b', 'C1', 'C2' ]
35.290 : DEBUG :  Opting in, graph 
35.290 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.290 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.290 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.290 : DEBUG :  Cluster identified C2 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.290 : DEBUG :  Nodes =  [ 'a', 'b', 'C1', 'C2' ] 0
35.290 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
35.290 : DEBUG :  Not a cluster a 0
35.290 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 2 } undefined  Depth  0
35.290 : DEBUG :  Not a cluster b 0
35.290 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
35.290 : INFO :  cp  a  to  C1  with parent  C1
35.290 : INFO :  In copy  C1 root C1 data undefined C1
35.290 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.290 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.290 : INFO :  Edge { v: 'C1', w: 'C2' }
35.290 : INFO :  Edge data { name: 'C1-external-link' } C1
35.290 : INFO :  Descendants of  C1  is  [ 'a' ]
35.290 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.290 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
35.290 : DEBUG :  Removing node a
35.290 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.290 : DEBUG :  Extracting node C2 Map(2) {
  'C1' => { id: 'a', clusterData: undefined },
  'C2' => { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
35.290 : INFO :  cp  b  to  C2  with parent  C2
35.290 : INFO :  In copy  C2 root C2 data undefined C2
35.290 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.290 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.290 : INFO :  Edge { v: 'C1', w: 'C2' }
35.290 : INFO :  Edge data { name: 'C1-external-link' } C2
35.290 : INFO :  Descendants of  C2  is  [ 'b' ]
35.290 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.290 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
35.290 : DEBUG :  Removing node b
35.290 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.290 : DEBUG :  Done, no node has children [ 'a' ]
35.290 : DEBUG :  Done, no node has children [ 'b' ]
35.290 : INFO :  [ 'C1', 'C2' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
35.291 : DEBUG :  Opting in, graph 
35.291 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.291 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.291 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.291 : DEBUG :  Nodes =  [ 'a', 'b', 'C1' ] 0
35.291 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: { data: 3 } },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
35.291 : DEBUG :  Not a cluster a 0
35.291 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: { data: 3 } },
  'C2' => { id: 'b', clusterData: undefined }
} false true { data: 2 } undefined  Depth  0
35.291 : DEBUG :  Not a cluster b 0
35.291 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: { data: 3 } },
  'C2' => { id: 'b', clusterData: undefined }
} true true { data: 3 } undefined  Depth  0
35.291 : INFO :  cp  a  to  C1  with parent  C1
35.291 : INFO :  In copy  C1 root C1 data { data: 3 } C1
35.291 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.291 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' } ]
35.291 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
35.291 : INFO :  Edge data { data: 'link1' } C1
35.291 : INFO :  Descendants of  C1  is  [ 'a' ]
35.291 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
35.291 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
35.291 : DEBUG :  Removing node a
35.291 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.291 : DEBUG :  Done, no node has children [ 'a' ]
35.291 : INFO :  [ { v: 'C1', w: 'b', name: '1' } ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
35.292 : INFO :  { data: 4 }
35.292 : DEBUG :  Opting in, graph 
35.292 : DEBUG :  Not a cluster  a Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.292 : DEBUG :  Not a cluster  b Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.292 : DEBUG :  Not a cluster  c Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.292 : DEBUG :  Cluster identified C1 Map(2) { 'C1' => [ 'a' ], 'C2' => [ 'b' ] }
35.292 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1' ] 0
35.292 : DEBUG :  Extracting node a Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
35.292 : DEBUG :  Not a cluster a 0
35.292 : DEBUG :  Extracting node b Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} false true { data: 2 } undefined  Depth  0
35.292 : DEBUG :  Not a cluster b 0
35.292 : DEBUG :  Extracting node c Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} false true { data: 3 } undefined  Depth  0
35.292 : DEBUG :  Not a cluster c 0
35.292 : DEBUG :  Extracting node C1 Map(2) {
  'C1' => { id: 'a', clusterData: { data: 4 } },
  'C2' => { id: 'b', clusterData: undefined }
} true true { data: 4 } undefined  Depth  0
35.292 : INFO :  cp  a  to  C1  with parent  C1
35.292 : INFO :  In copy  C1 root C1 data { data: 4 } C1
35.292 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.292 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]
35.292 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
35.292 : INFO :  Edge data { data: 'link1' } C1
35.292 : INFO :  Descendants of  C1  is  [ 'a' ]
35.292 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
35.292 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
35.292 : INFO :  Edge { v: 'C1', w: 'c', name: '2' }
35.292 : INFO :  Edge data { data: 'link2' } C1
35.292 : INFO :  Descendants of  C1  is  [ 'a' ]
35.292 : INFO :  Edge is  { v: 'C1', w: 'c', name: '2' }
35.292 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
35.292 : DEBUG :  Removing node a
35.292 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object] },
    { v: 'C1', value: [Object] }
  ],
  edges: [
    { v: 'C1', w: 'b', name: '1', value: [Object] },
    { v: 'C1', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.292 : DEBUG :  Done, no node has children [ 'a' ]
35.292 : INFO :  [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
35.293 : DEBUG :  Opting in, graph 
35.293 : DEBUG :  Not a cluster  a Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
35.293 : DEBUG :  Not a cluster  b Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
35.293 : DEBUG :  Not a cluster  c Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
35.293 : DEBUG :  Cluster identified A Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
35.293 : DEBUG :  Cluster identified B Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
35.293 : DEBUG :  Cluster identified C Map(5) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'c' ]
}
35.293 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'A', 'B', 'C' ] 0
35.293 : DEBUG :  Extracting node a Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} false false { data: 1 } undefined  Depth  0
35.293 : DEBUG :  Not a cluster a 0
35.293 : DEBUG :  Extracting node b Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} false false { data: 2 } undefined  Depth  0
35.293 : DEBUG :  Not a cluster b 0
35.293 : DEBUG :  Extracting node c Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} false false { data: 3 } undefined  Depth  0
35.293 : DEBUG :  Not a cluster c 0
35.293 : DEBUG :  Extracting node A Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.293 : INFO :  cp  a  to  A  with parent  A
35.293 : INFO :  In copy  A root A data undefined A
35.293 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.293 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.293 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.293 : INFO :  Edge data { data: 'link1' } A
35.293 : INFO :  Descendants of  A  is  [ 'a' ]
35.293 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.293 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
35.293 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.293 : INFO :  Edge data { data: 'link2' } A
35.293 : INFO :  Descendants of  A  is  [ 'a' ]
35.293 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.293 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
35.293 : DEBUG :  Removing node a
35.293 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B' },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.293 : DEBUG :  Extracting node B Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.293 : INFO :  cp  b  to  B  with parent  B
35.293 : INFO :  In copy  B root B data undefined B
35.293 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.293 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.293 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.293 : INFO :  Edge data { data: 'link1' } B
35.293 : INFO :  Descendants of  B  is  [ 'b' ]
35.293 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.293 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
35.293 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.293 : INFO :  Edge data { data: 'link2' } B
35.293 : INFO :  Descendants of  B  is  [ 'b' ]
35.293 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.293 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
35.293 : DEBUG :  Removing node b
35.293 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.293 : DEBUG :  Extracting node C Map(5) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.293 : INFO :  cp  c  to  C  with parent  C
35.293 : INFO :  In copy  C root C data undefined C
35.293 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.293 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.293 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.293 : INFO :  Edge data { data: 'link1' } C
35.293 : INFO :  Descendants of  C  is  [ 'c' ]
35.293 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.293 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
35.293 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.293 : INFO :  Edge data { data: 'link2' } C
35.293 : INFO :  Descendants of  C  is  [ 'c' ]
35.293 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.293 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
35.293 : DEBUG :  Removing node c
35.293 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.293 : DEBUG :  Done, no node has children [ 'a' ]
35.293 : DEBUG :  Done, no node has children [ 'b' ]
35.293 : DEBUG :  Done, no node has children [ 'c' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
35.295 : DEBUG :  Opting in, graph 
35.295 : DEBUG :  Cluster identified C Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.295 : DEBUG :  Cluster identified D Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.295 : DEBUG :  Not a cluster  d Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.295 : DEBUG :  Nodes =  [ 'C', 'D', 'd' ] 0
35.295 : DEBUG :  Extracting node C Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
35.295 : INFO :  cp  d  to  C  with parent  D
35.295 : DEBUG :  Setting parent d D
35.295 : DEBUG :  Copying Edges []
35.295 : DEBUG :  Removing node d
35.295 : INFO :  cp  D  to  C  with parent  D
35.295 : INFO :  In copy  D root C data { data: 2 } C
35.295 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
35.295 : DEBUG :  Copying Edges []
35.295 : DEBUG :  Removing node D
35.295 : DEBUG :  Removing node D
35.295 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.295 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
35.295 : DEBUG :  Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
}
35.295 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
35.295 : DEBUG :  Not a cluster d 0
35.295 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
35.295 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false false { data: 3 } [ 'd' ]  Depth  1
35.295 : DEBUG :  Not a cluster d 1
35.295 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: undefined },
  'B' => { id: 'b', clusterData: undefined },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
35.295 : INFO :  cp  d  to  D  with parent  D
35.295 : INFO :  In copy  D root D data { data: 2 } D
35.295 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
35.295 : DEBUG :  Copying Edges []
35.295 : DEBUG :  Removing node d
35.295 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.295 : DEBUG :  Done, no node has children [ 'd' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
35.296 : INFO :  Graph before { data: 2 }
35.296 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'D', value: [Object], parent: 'C' },
    { v: 'd', value: [Object], parent: 'D' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.296 : DEBUG :  Opting in, graph 
35.296 : DEBUG :  Cluster identified C Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.296 : DEBUG :  Cluster identified D Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.296 : DEBUG :  Not a cluster  d Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.296 : DEBUG :  Cluster identified B Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.296 : DEBUG :  Not a cluster  b Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.296 : DEBUG :  Cluster identified A Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.296 : DEBUG :  Not a cluster  a Map(6) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ]
}
35.296 : DEBUG :  Nodes =  [
  'C', 'D', 'd',
  'B', 'b', 'A',
  'a'
] 0
35.296 : DEBUG :  Extracting node C Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
35.296 : INFO :  cp  d  to  C  with parent  D
35.296 : DEBUG :  Setting parent d D
35.296 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.296 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Edge data { data: 'link1' } C
35.296 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
35.296 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Edge data { data: 'link2' } C
35.296 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
35.296 : DEBUG :  Removing node d
35.296 : INFO :  cp  D  to  C  with parent  D
35.296 : INFO :  In copy  D root C data { data: 2 } C
35.296 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
35.296 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.296 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Edge data { data: 'link1' } C
35.296 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
35.296 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Edge data { data: 'link2' } C
35.296 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
35.296 : DEBUG :  Removing node D
35.296 : DEBUG :  Removing node D
35.296 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.296 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
35.296 : DEBUG :  Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
}
35.296 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
35.296 : DEBUG :  Not a cluster d 0
35.296 : DEBUG :  Extracting node B Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 4 } undefined  Depth  0
35.296 : INFO :  cp  b  to  B  with parent  B
35.296 : INFO :  In copy  B root B data { data: 4 } B
35.296 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.296 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.296 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Edge data { data: 'link1' } B
35.296 : INFO :  Descendants of  B  is  [ 'b' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
35.296 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Edge data { data: 'link2' } B
35.296 : INFO :  Descendants of  B  is  [ 'b' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
35.296 : DEBUG :  Removing node b
35.296 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.296 : DEBUG :  Extracting node b Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
35.296 : DEBUG :  Not a cluster b 0
35.296 : DEBUG :  Extracting node A Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 6 } undefined  Depth  0
35.296 : INFO :  cp  a  to  A  with parent  A
35.296 : INFO :  In copy  A root A data { data: 6 } A
35.296 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.296 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.296 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Edge data { data: 'link1' } A
35.296 : INFO :  Descendants of  A  is  [ 'a' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.296 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
35.296 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Edge data { data: 'link2' } A
35.296 : INFO :  Descendants of  A  is  [ 'a' ]
35.296 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.296 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
35.296 : DEBUG :  Removing node a
35.296 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.296 : DEBUG :  Extracting node a Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
35.296 : DEBUG :  Not a cluster a 0
35.296 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
35.296 : DEBUG :  Extracting node d Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} false false { data: 3 } [ 'd' ]  Depth  1
35.296 : DEBUG :  Not a cluster d 1
35.296 : DEBUG :  Extracting node D Map(6) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
35.296 : INFO :  cp  d  to  D  with parent  D
35.296 : INFO :  In copy  D root D data { data: 2 } D
35.296 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
35.296 : DEBUG :  Copying Edges []
35.296 : DEBUG :  Removing node d
35.296 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.296 : DEBUG :  Done, no node has children [ 'd' ]
35.296 : DEBUG :  Done, no node has children [ 'b' ]
35.296 : DEBUG :  Done, no node has children [ 'a' ]
35.296 : INFO :  A [ 'a' ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
35.300 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'd', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'b' }
  ],
  edges: [
    { v: 'a', w: 'b', name: '1', value: [Object] },
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.300 : DEBUG :  Opting in, graph 
35.300 : DEBUG :  Not a cluster  a Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
35.300 : DEBUG :  Cluster identified b Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
35.300 : DEBUG :  Not a cluster  c Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
35.300 : DEBUG :  Not a cluster  d Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
35.300 : DEBUG :  Not a cluster  e Map(7) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'd', 'e' ]
}
35.300 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'd', 'e' ] 0
35.300 : DEBUG :  Extracting node a Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true { data: 1 } undefined  Depth  0
35.300 : DEBUG :  Not a cluster a 0
35.300 : DEBUG :  Extracting node b Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} true true { data: 2 } undefined  Depth  0
35.300 : INFO :  cp  c  to  b  with parent  b
35.300 : INFO :  In copy  b root b data { data: 2 } b
35.300 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.300 : DEBUG :  Copying Edges [
  { v: 'c', w: 'd', name: '2' },
  { v: 'd', w: 'e', name: '2' },
  { v: 'a', w: 'b', name: '1' }
]
35.300 : INFO :  Edge { v: 'c', w: 'd', name: '2' }
35.300 : INFO :  Edge data { data: 'link2' } b
35.300 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.300 : INFO :  Edge is  { v: 'c', w: 'd', name: '2' }
35.300 : INFO :  Copying as  c d { data: 'link2' } 2
35.300 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' } ] { data: 'link2' }
35.300 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
35.300 : INFO :  Edge data { data: 'link2' } b
35.300 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.300 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
35.300 : INFO :  Copying as  d e { data: 'link2' } 2
35.300 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
35.300 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
35.300 : INFO :  Edge data { data: 'link1' } b
35.300 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.300 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
35.300 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
35.300 : DEBUG :  Removing node c
35.300 : INFO :  cp  d  to  b  with parent  b
35.300 : INFO :  In copy  b root b data { data: 2 } b
35.300 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
35.300 : DEBUG :  Copying Edges [ { v: 'd', w: 'e', name: '2' }, { v: 'a', w: 'b', name: '1' } ]
35.300 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
35.300 : INFO :  Edge data { data: 'link2' } b
35.300 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.300 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
35.300 : INFO :  Copying as  d e { data: 'link2' } 2
35.300 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
35.300 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
35.300 : INFO :  Edge data { data: 'link1' } b
35.300 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.300 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
35.300 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
35.300 : DEBUG :  Removing node d
35.300 : INFO :  cp  e  to  b  with parent  b
35.300 : INFO :  In copy  b root b data { data: 2 } b
35.300 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
35.300 : DEBUG :  Copying Edges [ { v: 'a', w: 'b', name: '1' } ]
35.300 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
35.300 : INFO :  Edge data { data: 'link1' } b
35.300 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.300 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
35.300 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
35.300 : DEBUG :  Removing node e
35.300 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] }, { v: 'b', value: [Object] } ],
  edges: [ { v: 'a', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.300 : DEBUG :  Extracting node c Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
35.300 : DEBUG :  Not a cluster c 0
35.300 : DEBUG :  Extracting node d Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
35.300 : DEBUG :  Not a cluster d 0
35.300 : DEBUG :  Extracting node e Map(7) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'b', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'b', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } }
} false true undefined undefined  Depth  0
35.300 : DEBUG :  Not a cluster e 0
35.300 : DEBUG :  Done, no node has children [ 'c', 'd', 'e' ]
35.300 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object] },
    { v: 'd', value: [Object] },
    { v: 'e', value: [Object] }
  ],
  edges: [
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
35.303 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object], parent: 'a' },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'c' }
  ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.303 : DEBUG :  Opting in, graph 
35.303 : DEBUG :  Cluster identified a Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.303 : DEBUG :  Cluster identified b Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.303 : DEBUG :  Cluster identified c Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.303 : DEBUG :  Not a cluster  e Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'a' ],
  'B' => [ 'b' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.303 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'e' ] 0
35.303 : DEBUG :  Extracting node a Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true { data: 1 } undefined  Depth  0
35.303 : INFO :  cp  e  to  a  with parent  c
35.303 : DEBUG :  Setting parent e c
35.303 : DEBUG :  Copying Edges []
35.303 : DEBUG :  Removing node e
35.303 : INFO :  cp  c  to  a  with parent  c
35.303 : INFO :  In copy  c root a data { data: 3 } a
35.303 : DEBUG :  Not Setting parent for node= c cluster!==rootId true node!==clusterId false
35.303 : DEBUG :  Copying Edges []
35.303 : DEBUG :  Removing node c
35.303 : DEBUG :  Removing node c
35.303 : INFO :  cp  b  to  a  with parent  b
35.303 : INFO :  In copy  b root a data { data: 2 } a
35.303 : DEBUG :  Not Setting parent for node= b cluster!==rootId true node!==clusterId false
35.303 : DEBUG :  Copying Edges []
35.303 : DEBUG :  Removing node b
35.303 : DEBUG :  Removing node b
35.303 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.303 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.303 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.303 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.303 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.303 : DEBUG :  Extracting node e Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false true undefined undefined  Depth  0
35.303 : DEBUG :  Not a cluster e 0
35.303 : DEBUG :  Nodes =  [ 'e', 'c', 'b' ] 1
35.303 : DEBUG :  Extracting node e Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false false { data: 3 } undefined  Depth  1
35.303 : DEBUG :  Not a cluster e 1
35.303 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true false { data: 3 } undefined  Depth  1
35.303 : INFO :  cp  e  to  c  with parent  c
35.303 : INFO :  In copy  c root c data { data: 3 } c
35.303 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
35.303 : DEBUG :  Copying Edges []
35.303 : DEBUG :  Removing node e
35.303 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'b', value: [Object] }
  ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.303 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'B', clusterData: undefined },
  'A' => { id: 'a', clusterData: { data: 6 } },
  'B' => { id: 'a', clusterData: { data: 4 } },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'a', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true { data: 2 } undefined  Depth  1
35.303 : INFO :  cp  c  to  b  with parent  b
35.303 : INFO :  In copy  b root b data { data: 2 } b
35.303 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.303 : DEBUG :  Copying Edges []
35.303 : DEBUG :  Removing node c
35.303 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.303 : DEBUG :  Done, no node has children [ 'c' ]
35.303 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
35.304 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object], parent: 'A' },
    { v: 'b', value: [Object], parent: 'A' },
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'b', w: 'B', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.304 : DEBUG :  Opting in, graph 
35.304 : DEBUG :  Cluster identified A Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.304 : DEBUG :  Cluster identified B Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.304 : DEBUG :  Not a cluster  b Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.304 : DEBUG :  Not a cluster  c Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.304 : DEBUG :  Not a cluster  a Map(9) {
  'C1' => [ 'a' ],
  'C2' => [ 'b' ],
  'A' => [ 'B', 'b', 'a', 'c' ],
  'B' => [ 'c' ],
  'C' => [ 'D', 'd' ],
  'D' => [ 'd' ],
  'b' => [ 'c', 'e' ],
  'a' => [ 'b', 'c', 'e' ],
  'c' => [ 'e' ]
}
35.304 : DEBUG :  Nodes =  [ 'A', 'B', 'b', 'c', 'a' ] 0
35.304 : DEBUG :  Extracting node A Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  cssClass: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  0
35.304 : INFO :  cp  c  to  A  with parent  B
35.304 : DEBUG :  Setting parent c B
35.304 : DEBUG :  Copying Edges [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ]
35.304 : INFO :  Edge { v: 'b', w: 'c', name: '1' }
35.304 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} A
35.304 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
35.304 : INFO :  Edge is  { v: 'b', w: 'c', name: '1' }
35.304 : INFO :  Copying as  b c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} 1
35.304 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
35.304 : INFO :  Edge { v: 'a', w: 'c', name: '2' }
35.304 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  cssClasses: 'flowchart-link LS-a LE-c'
} A
35.304 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
35.304 : INFO :  Edge is  { v: 'a', w: 'c', name: '2' }
35.304 : INFO :  Copying as  a c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  cssClasses: 'flowchart-link LS-a LE-c'
} 2
35.304 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  cssClasses: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
35.304 : DEBUG :  Removing node c
35.304 : INFO :  cp  B  to  A  with parent  B
35.304 : INFO :  In copy  B root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} A
35.304 : DEBUG :  Not Setting parent for node= B cluster!==rootId true node!==clusterId false
35.304 : DEBUG :  Copying Edges []
35.304 : DEBUG :  Removing node B
35.304 : DEBUG :  Removing node B
35.304 : INFO :  cp  b  to  A  with parent  A
35.304 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  cssClass: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
35.304 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.304 : DEBUG :  Copying Edges []
35.304 : DEBUG :  Removing node b
35.304 : INFO :  cp  a  to  A  with parent  A
35.304 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  cssClass: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
35.304 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.304 : DEBUG :  Copying Edges []
35.304 : DEBUG :  Removing node a
35.304 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'A', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.304 : DEBUG :  Extracting node B Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false true undefined undefined  Depth  0
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : DEBUG :  Extracting node a Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : DEBUG :  Nodes =  [ 'c', 'B', 'b', 'a' ] 1
35.304 : DEBUG :  Extracting node c Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true false {
  labelStyle: '',
  shape: 'rect',
  labelText: 'c',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'c',
  padding: 15
} undefined  Depth  1
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : DEBUG :  Extracting node B Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} false true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  1
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : DEBUG :  Extracting node b Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'b',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'b',
  padding: 15
} undefined  Depth  1
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : DEBUG :  Extracting node a Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'a',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'a',
  padding: 15
} undefined  Depth  1
35.304 : DEBUG :  Map(9) {
  'C1' => { id: 'A', clusterData: { data: 4 } },
  'C2' => { id: 'A', clusterData: undefined },
  'A' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      cssClass: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  'B' => {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  'C' => { id: 'D', clusterData: { data: 1 } },
  'D' => { id: 'A', clusterData: { data: 2 } },
  'b' => { id: 'c', clusterData: { data: 2 } },
  'a' => { id: 'c', clusterData: { data: 1 } },
  'c' => { id: 'e', clusterData: { data: 3 } }
}
35.304 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'a', value: [Object] }
  ],
  edges: [
    { v: 'b', w: 'c', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

 ✓ packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js  (15 tests) 30ms
 ✓ packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js  (15 tests) 20ms
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
35.412 : DEBUG :  Opting in, graph 
35.412 : DEBUG :  Not a cluster  a { C1: [ 'a', 'b' ], C2: [ 'c' ] }
35.412 : DEBUG :  Not a cluster  b { C1: [ 'a', 'b' ], C2: [ 'c' ] }
35.412 : DEBUG :  Not a cluster  c { C1: [ 'a', 'b' ], C2: [ 'c' ] }
35.412 : DEBUG :  Cluster identified C1 { C1: [ 'a', 'b' ], C2: [ 'c' ] }
35.412 : DEBUG :  Cluster identified C2 { C1: [ 'a', 'b' ], C2: [ 'c' ] }
35.412 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
35.412 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} undefined false {} undefined  Depth  0
35.412 : DEBUG :  Not a cluster a 0
35.412 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} undefined false {} undefined  Depth  0
35.412 : DEBUG :  Not a cluster b 0
35.412 : DEBUG :  Extracting node c {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} undefined false {} undefined  Depth  0
35.412 : DEBUG :  Not a cluster c 0
35.412 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.412 : INFO :  cp  a  to  C1  with parent  C1
35.412 : INFO :  In copy  C1 root C1 data undefined C1
35.412 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.412 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'C2' } ]
35.412 : INFO :  Edge { v: 'a', w: 'b' }
35.412 : INFO :  Edge data {} C1
35.412 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
35.412 : INFO :  Edge is  { v: 'a', w: 'b' }
35.412 : INFO :  Copying as  a b {} undefined
35.412 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] {}
35.412 : INFO :  Edge { v: 'C1', w: 'C2' }
35.412 : INFO :  Edge data {} C1
35.412 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
35.412 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.412 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
35.412 : DEBUG :  Removing node a
35.412 : INFO :  cp  b  to  C1  with parent  C1
35.412 : INFO :  In copy  C1 root C1 data undefined C1
35.412 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.412 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.412 : INFO :  Edge { v: 'C1', w: 'C2' }
35.412 : INFO :  Edge data {} C1
35.412 : INFO :  Descendants of  C1  is  [ 'a', 'b' ]
35.412 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.412 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
35.412 : DEBUG :  Removing node b
35.412 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: {}, parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.412 : DEBUG :  Extracting node C2 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.412 : INFO :  cp  c  to  C2  with parent  C2
35.412 : INFO :  In copy  C2 root C2 data undefined C2
35.412 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.412 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.412 : INFO :  Edge { v: 'C1', w: 'C2' }
35.412 : INFO :  Edge data {} C2
35.412 : INFO :  Descendants of  C2  is  [ 'c' ]
35.412 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.412 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
35.412 : DEBUG :  Removing node c
35.412 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: {} } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.412 : DEBUG :  Done, no node has children [ 'a', 'b' ]
35.412 : DEBUG :  Done, no node has children [ 'c' ]
35.412 : INFO :  [ { v: 'C1', w: 'C2' } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
35.416 : DEBUG :  Opting in, graph 
35.416 : DEBUG :  Not a cluster  a { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
35.416 : DEBUG :  Not a cluster  b { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
35.416 : DEBUG :  Not a cluster  c { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
35.416 : DEBUG :  Cluster identified C1 { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
35.416 : DEBUG :  Cluster identified C2 { C1: [ 'b', 'C2', 'a' ], C2: [ 'a' ] }
35.416 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1', 'C2' ] 0
35.416 : DEBUG :  Extracting node a {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined false { data: 1 } undefined  Depth  0
35.416 : DEBUG :  Not a cluster a 0
35.416 : DEBUG :  Extracting node b {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined false { data: 2 } undefined  Depth  0
35.416 : DEBUG :  Not a cluster b 0
35.416 : DEBUG :  Extracting node c {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined true { data: 3 } undefined  Depth  0
35.416 : DEBUG :  Not a cluster c 0
35.416 : DEBUG :  Extracting node C1 {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} true true { data: 4 } undefined  Depth  0
35.416 : INFO :  cp  b  to  C1  with parent  C1
35.416 : INFO :  In copy  C1 root C1 data { data: 4 } C1
35.416 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.416 : DEBUG :  Copying Edges [ { v: 'a', w: 'b' }, { v: 'C1', w: 'c' } ]
35.416 : INFO :  Edge { v: 'a', w: 'b' }
35.416 : INFO :  Edge data { name: 'C1-internal-link' } C1
35.416 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.416 : INFO :  Edge is  { v: 'a', w: 'b' }
35.416 : INFO :  Copying as  a b { name: 'C1-internal-link' } undefined
35.416 : INFO :  newGraph edges  [ { v: 'a', w: 'b' } ] { name: 'C1-internal-link' }
35.416 : INFO :  Edge { v: 'C1', w: 'c' }
35.416 : INFO :  Edge data { name: 'C1-external-link' } C1
35.416 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.416 : INFO :  Edge is  { v: 'C1', w: 'c' }
35.416 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
35.416 : DEBUG :  Removing node b
35.416 : INFO :  cp  a  to  C1  with parent  C2
35.416 : DEBUG :  Setting parent a C2
35.416 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
35.416 : INFO :  Edge { v: 'C1', w: 'c' }
35.416 : INFO :  Edge data { name: 'C1-external-link' } C1
35.416 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.416 : INFO :  Edge is  { v: 'C1', w: 'c' }
35.416 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
35.416 : DEBUG :  Removing node a
35.416 : INFO :  cp  C2  to  C1  with parent  C2
35.416 : INFO :  In copy  C2 root C1 data { data: 5 } C1
35.416 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId true node!==clusterId false
35.416 : DEBUG :  Copying Edges [ { v: 'C1', w: 'c' } ]
35.416 : INFO :  Edge { v: 'C1', w: 'c' }
35.416 : INFO :  Edge data { name: 'C1-external-link' } C1
35.416 : INFO :  Descendants of  C1  is  [ 'b', 'C2', 'a' ]
35.416 : INFO :  Edge is  { v: 'C1', w: 'c' }
35.416 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
35.416 : DEBUG :  Removing node C2
35.416 : DEBUG :  Removing node C2
35.416 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'c', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'c', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.416 : DEBUG :  Extracting node C2 {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true undefined undefined  Depth  0
35.416 : DEBUG :  {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
35.416 : DEBUG :  Nodes =  [ 'b', 'a', 'C2' ] 1
35.416 : DEBUG :  Extracting node b {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined true { data: 2 } undefined  Depth  1
35.416 : DEBUG :  Not a cluster b 1
35.416 : DEBUG :  Extracting node a {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} undefined false { data: 1 } undefined  Depth  1
35.416 : DEBUG :  Not a cluster a 1
35.416 : DEBUG :  Extracting node C2 {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
} false true { data: 5 } undefined  Depth  1
35.416 : DEBUG :  {
  C1: { id: 'b', clusterData: { data: 4 } },
  C2: { id: 'a', clusterData: { data: 5 }, externalConnections: true }
}
35.416 : INFO :  [ 'c', 'C1' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
35.417 : INFO :  [ 'a', 'b', 'C1', 'C2' ]
35.417 : DEBUG :  Opting in, graph 
35.417 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ] }
35.417 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ] }
35.417 : DEBUG :  Cluster identified C1 { C1: [ 'a' ], C2: [ 'b' ] }
35.417 : DEBUG :  Cluster identified C2 { C1: [ 'a' ], C2: [ 'b' ] }
35.417 : DEBUG :  Nodes =  [ 'a', 'b', 'C1', 'C2' ] 0
35.417 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
35.417 : DEBUG :  Not a cluster a 0
35.417 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 2 } undefined  Depth  0
35.417 : DEBUG :  Not a cluster b 0
35.417 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
35.417 : INFO :  cp  a  to  C1  with parent  C1
35.417 : INFO :  In copy  C1 root C1 data undefined C1
35.417 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.417 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.417 : INFO :  Edge { v: 'C1', w: 'C2' }
35.417 : INFO :  Edge data { name: 'C1-external-link' } C1
35.417 : INFO :  Descendants of  C1  is  [ 'a' ]
35.417 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.417 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
35.417 : DEBUG :  Removing node a
35.417 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'C2' },
    { v: 'C1', value: [Object] },
    { v: 'C2' }
  ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.417 : DEBUG :  Extracting node C2 {
  C1: { id: 'a', clusterData: undefined },
  C2: { id: 'b', clusterData: undefined }
} true true undefined undefined  Depth  0
35.417 : INFO :  cp  b  to  C2  with parent  C2
35.417 : INFO :  In copy  C2 root C2 data undefined C2
35.417 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.417 : DEBUG :  Copying Edges [ { v: 'C1', w: 'C2' } ]
35.417 : INFO :  Edge { v: 'C1', w: 'C2' }
35.417 : INFO :  Edge data { name: 'C1-external-link' } C2
35.417 : INFO :  Descendants of  C2  is  [ 'b' ]
35.417 : INFO :  Edge is  { v: 'C1', w: 'C2' }
35.417 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
35.417 : DEBUG :  Removing node b
35.417 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C1', value: [Object] }, { v: 'C2', value: [Object] } ],
  edges: [ { v: 'C1', w: 'C2', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.417 : DEBUG :  Done, no node has children [ 'a' ]
35.417 : DEBUG :  Done, no node has children [ 'b' ]
35.417 : INFO :  [ 'C1', 'C2' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
35.418 : DEBUG :  Opting in, graph 
35.418 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ] }
35.418 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ] }
35.418 : DEBUG :  Cluster identified C1 { C1: [ 'a' ], C2: [ 'b' ] }
35.418 : DEBUG :  Nodes =  [ 'a', 'b', 'C1' ] 0
35.418 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: { data: 3 } },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
35.418 : DEBUG :  Not a cluster a 0
35.418 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: { data: 3 } },
  C2: { id: 'b', clusterData: undefined }
} undefined true { data: 2 } undefined  Depth  0
35.418 : DEBUG :  Not a cluster b 0
35.418 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: { data: 3 } },
  C2: { id: 'b', clusterData: undefined }
} true true { data: 3 } undefined  Depth  0
35.418 : INFO :  cp  a  to  C1  with parent  C1
35.418 : INFO :  In copy  C1 root C1 data { data: 3 } C1
35.418 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.418 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' } ]
35.418 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
35.418 : INFO :  Edge data { data: 'link1' } C1
35.418 : INFO :  Descendants of  C1  is  [ 'a' ]
35.418 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
35.418 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
35.418 : DEBUG :  Removing node a
35.418 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] }, { v: 'C1', value: [Object] } ],
  edges: [ { v: 'C1', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.418 : DEBUG :  Done, no node has children [ 'a' ]
35.418 : INFO :  [ { v: 'C1', w: 'b', name: '1' } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
35.419 : INFO :  { data: 4 }
35.419 : DEBUG :  Opting in, graph 
35.419 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ] }
35.419 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ] }
35.419 : DEBUG :  Not a cluster  c { C1: [ 'a' ], C2: [ 'b' ] }
35.419 : DEBUG :  Cluster identified C1 { C1: [ 'a' ], C2: [ 'b' ] }
35.419 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'C1' ] 0
35.419 : DEBUG :  Extracting node a {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
35.419 : DEBUG :  Not a cluster a 0
35.419 : DEBUG :  Extracting node b {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} undefined true { data: 2 } undefined  Depth  0
35.419 : DEBUG :  Not a cluster b 0
35.419 : DEBUG :  Extracting node c {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} undefined true { data: 3 } undefined  Depth  0
35.419 : DEBUG :  Not a cluster c 0
35.419 : DEBUG :  Extracting node C1 {
  C1: { id: 'a', clusterData: { data: 4 } },
  C2: { id: 'b', clusterData: undefined }
} true true { data: 4 } undefined  Depth  0
35.419 : INFO :  cp  a  to  C1  with parent  C1
35.419 : INFO :  In copy  C1 root C1 data { data: 4 } C1
35.419 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.419 : DEBUG :  Copying Edges [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]
35.419 : INFO :  Edge { v: 'C1', w: 'b', name: '1' }
35.419 : INFO :  Edge data { data: 'link1' } C1
35.419 : INFO :  Descendants of  C1  is  [ 'a' ]
35.419 : INFO :  Edge is  { v: 'C1', w: 'b', name: '1' }
35.419 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
35.419 : INFO :  Edge { v: 'C1', w: 'c', name: '2' }
35.419 : INFO :  Edge data { data: 'link2' } C1
35.419 : INFO :  Descendants of  C1  is  [ 'a' ]
35.419 : INFO :  Edge is  { v: 'C1', w: 'c', name: '2' }
35.419 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
35.419 : DEBUG :  Removing node a
35.419 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object] },
    { v: 'C1', value: [Object] }
  ],
  edges: [
    { v: 'C1', w: 'b', name: '1', value: [Object] },
    { v: 'C1', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.419 : DEBUG :  Done, no node has children [ 'a' ]
35.419 : INFO :  [ { v: 'C1', w: 'b', name: '1' }, { v: 'C1', w: 'c', name: '2' } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
35.420 : DEBUG :  Opting in, graph 
35.420 : DEBUG :  Not a cluster  a { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
35.420 : DEBUG :  Not a cluster  b { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
35.420 : DEBUG :  Not a cluster  c { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
35.420 : DEBUG :  Cluster identified A { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
35.420 : DEBUG :  Cluster identified B { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
35.420 : DEBUG :  Cluster identified C { C1: [ 'a' ], C2: [ 'b' ], A: [ 'a' ], B: [ 'b' ], C: [ 'c' ] }
35.420 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'A', 'B', 'C' ] 0
35.420 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} undefined false { data: 1 } undefined  Depth  0
35.420 : DEBUG :  Not a cluster a 0
35.420 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} undefined false { data: 2 } undefined  Depth  0
35.420 : DEBUG :  Not a cluster b 0
35.420 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} undefined false { data: 3 } undefined  Depth  0
35.420 : DEBUG :  Not a cluster c 0
35.420 : DEBUG :  Extracting node A {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.420 : INFO :  cp  a  to  A  with parent  A
35.420 : INFO :  In copy  A root A data undefined A
35.420 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.420 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.420 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.420 : INFO :  Edge data { data: 'link1' } A
35.420 : INFO :  Descendants of  A  is  [ 'a' ]
35.420 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.420 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
35.420 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.420 : INFO :  Edge data { data: 'link2' } A
35.420 : INFO :  Descendants of  A  is  [ 'a' ]
35.420 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.420 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
35.420 : DEBUG :  Removing node a
35.420 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B' },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.420 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.420 : INFO :  cp  b  to  B  with parent  B
35.420 : INFO :  In copy  B root B data undefined B
35.420 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.420 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.420 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.420 : INFO :  Edge data { data: 'link1' } B
35.420 : INFO :  Descendants of  B  is  [ 'b' ]
35.420 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.420 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
35.420 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.420 : INFO :  Edge data { data: 'link2' } B
35.420 : INFO :  Descendants of  B  is  [ 'b' ]
35.420 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.420 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
35.420 : DEBUG :  Removing node b
35.420 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'C' },
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.420 : DEBUG :  Extracting node C {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'c', clusterData: undefined }
} true true undefined undefined  Depth  0
35.420 : INFO :  cp  c  to  C  with parent  C
35.420 : INFO :  In copy  C root C data undefined C
35.420 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.420 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.420 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.420 : INFO :  Edge data { data: 'link1' } C
35.420 : INFO :  Descendants of  C  is  [ 'c' ]
35.420 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.420 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
35.420 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.420 : INFO :  Edge data { data: 'link2' } C
35.420 : INFO :  Descendants of  C  is  [ 'c' ]
35.420 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.420 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
35.420 : DEBUG :  Removing node c
35.420 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.420 : DEBUG :  Done, no node has children [ 'a' ]
35.420 : DEBUG :  Done, no node has children [ 'b' ]
35.420 : DEBUG :  Done, no node has children [ 'c' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
35.422 : DEBUG :  Opting in, graph 
35.422 : DEBUG :  Cluster identified C {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.422 : DEBUG :  Cluster identified D {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.422 : DEBUG :  Not a cluster  d {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.422 : DEBUG :  Nodes =  [ 'C', 'D', 'd' ] 0
35.422 : DEBUG :  Extracting node C {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
35.422 : INFO :  cp  d  to  C  with parent  D
35.422 : DEBUG :  Setting parent d D
35.422 : DEBUG :  Copying Edges []
35.422 : DEBUG :  Removing node d
35.422 : INFO :  cp  D  to  C  with parent  D
35.422 : INFO :  In copy  D root C data { data: 2 } C
35.422 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
35.422 : DEBUG :  Copying Edges []
35.422 : DEBUG :  Removing node D
35.422 : DEBUG :  Removing node D
35.422 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'C', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.422 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
35.422 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
}
35.422 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
35.422 : DEBUG :  Not a cluster d 0
35.422 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
35.422 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined false { data: 3 } [ 'd' ]  Depth  1
35.422 : DEBUG :  Not a cluster d 1
35.422 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: undefined },
  B: { id: 'b', clusterData: undefined },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
35.422 : INFO :  cp  d  to  D  with parent  D
35.422 : INFO :  In copy  D root D data { data: 2 } D
35.422 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
35.422 : DEBUG :  Copying Edges []
35.422 : DEBUG :  Removing node d
35.422 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.422 : DEBUG :  Done, no node has children [ 'd' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
35.423 : INFO :  Graph before { data: 2 }
35.423 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'D', value: [Object], parent: 'C' },
    { v: 'd', value: [Object], parent: 'D' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.423 : DEBUG :  Opting in, graph 
35.423 : DEBUG :  Cluster identified C {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.423 : DEBUG :  Cluster identified D {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.423 : DEBUG :  Not a cluster  d {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.423 : DEBUG :  Cluster identified B {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.423 : DEBUG :  Not a cluster  b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.423 : DEBUG :  Cluster identified A {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.423 : DEBUG :  Not a cluster  a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ]
}
35.423 : DEBUG :  Nodes =  [
  'C', 'D', 'd',
  'B', 'b', 'A',
  'a'
] 0
35.423 : DEBUG :  Extracting node C {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 1 } [ 'd' ]  Depth  0
35.423 : INFO :  cp  d  to  C  with parent  D
35.423 : DEBUG :  Setting parent d D
35.423 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.423 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Edge data { data: 'link1' } C
35.423 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
35.423 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Edge data { data: 'link2' } C
35.423 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
35.423 : DEBUG :  Removing node d
35.423 : INFO :  cp  D  to  C  with parent  D
35.423 : INFO :  In copy  D root C data { data: 2 } C
35.423 : DEBUG :  Not Setting parent for node= D cluster!==rootId true node!==clusterId false
35.423 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.423 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Edge data { data: 'link1' } C
35.423 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
35.423 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Edge data { data: 'link2' } C
35.423 : INFO :  Descendants of  C  is  [ 'D', 'd' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
35.423 : DEBUG :  Removing node D
35.423 : DEBUG :  Removing node D
35.423 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object], parent: 'B' },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.423 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true undefined undefined  Depth  0
35.423 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
}
35.423 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
35.423 : DEBUG :  Not a cluster d 0
35.423 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 4 } undefined  Depth  0
35.423 : INFO :  cp  b  to  B  with parent  B
35.423 : INFO :  In copy  B root B data { data: 4 } B
35.423 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.423 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.423 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Edge data { data: 'link1' } B
35.423 : INFO :  Descendants of  B  is  [ 'b' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
35.423 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Edge data { data: 'link2' } B
35.423 : INFO :  Descendants of  B  is  [ 'b' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
35.423 : DEBUG :  Removing node b
35.423 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.423 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
35.423 : DEBUG :  Not a cluster b 0
35.423 : DEBUG :  Extracting node A {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 6 } undefined  Depth  0
35.423 : INFO :  cp  a  to  A  with parent  A
35.423 : INFO :  In copy  A root A data { data: 6 } A
35.423 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.423 : DEBUG :  Copying Edges [ { v: 'A', w: 'B', name: '1' }, { v: 'A', w: 'C', name: '2' } ]
35.423 : INFO :  Edge { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Edge data { data: 'link1' } A
35.423 : INFO :  Descendants of  A  is  [ 'a' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'B', name: '1' }
35.423 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
35.423 : INFO :  Edge { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Edge data { data: 'link2' } A
35.423 : INFO :  Descendants of  A  is  [ 'a' ]
35.423 : INFO :  Edge is  { v: 'A', w: 'C', name: '2' }
35.423 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
35.423 : DEBUG :  Removing node a
35.423 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'C', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'A', value: [Object] }
  ],
  edges: [
    { v: 'A', w: 'B', name: '1', value: [Object] },
    { v: 'A', w: 'C', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.423 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
35.423 : DEBUG :  Not a cluster a 0
35.423 : DEBUG :  Nodes =  [ 'd', 'D' ] 1
35.423 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} undefined false { data: 3 } [ 'd' ]  Depth  1
35.423 : DEBUG :  Not a cluster d 1
35.423 : DEBUG :  Extracting node D {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'd', clusterData: { data: 2 } }
} true true { data: 2 } [ 'd' ]  Depth  1
35.423 : INFO :  cp  d  to  D  with parent  D
35.423 : INFO :  In copy  D root D data { data: 2 } D
35.423 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
35.423 : DEBUG :  Copying Edges []
35.423 : DEBUG :  Removing node d
35.423 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'D', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.423 : DEBUG :  Done, no node has children [ 'd' ]
35.423 : DEBUG :  Done, no node has children [ 'b' ]
35.423 : DEBUG :  Done, no node has children [ 'a' ]
35.423 : INFO :  A [ 'a' ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
35.425 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'd', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'b' }
  ],
  edges: [
    { v: 'a', w: 'b', name: '1', value: [Object] },
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.425 : DEBUG :  Opting in, graph 
35.425 : DEBUG :  Not a cluster  a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
35.425 : DEBUG :  Cluster identified b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
35.425 : DEBUG :  Not a cluster  c {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
35.425 : DEBUG :  Not a cluster  d {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
35.425 : DEBUG :  Not a cluster  e {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'd', 'e' ]
}
35.425 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'd', 'e' ] 0
35.425 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true { data: 1 } undefined  Depth  0
35.425 : DEBUG :  Not a cluster a 0
35.425 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} true true { data: 2 } undefined  Depth  0
35.425 : INFO :  cp  c  to  b  with parent  b
35.425 : INFO :  In copy  b root b data { data: 2 } b
35.425 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.425 : DEBUG :  Copying Edges [
  { v: 'c', w: 'd', name: '2' },
  { v: 'd', w: 'e', name: '2' },
  { v: 'a', w: 'b', name: '1' }
]
35.425 : INFO :  Edge { v: 'c', w: 'd', name: '2' }
35.425 : INFO :  Edge data { data: 'link2' } b
35.425 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.425 : INFO :  Edge is  { v: 'c', w: 'd', name: '2' }
35.425 : INFO :  Copying as  c d { data: 'link2' } 2
35.425 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' } ] { data: 'link2' }
35.425 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
35.425 : INFO :  Edge data { data: 'link2' } b
35.425 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.425 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
35.425 : INFO :  Copying as  d e { data: 'link2' } 2
35.425 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
35.425 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
35.425 : INFO :  Edge data { data: 'link1' } b
35.425 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.425 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
35.425 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
35.425 : DEBUG :  Removing node c
35.425 : INFO :  cp  d  to  b  with parent  b
35.425 : INFO :  In copy  b root b data { data: 2 } b
35.425 : DEBUG :  Not Setting parent for node= d cluster!==rootId false node!==clusterId true
35.425 : DEBUG :  Copying Edges [ { v: 'd', w: 'e', name: '2' }, { v: 'a', w: 'b', name: '1' } ]
35.425 : INFO :  Edge { v: 'd', w: 'e', name: '2' }
35.425 : INFO :  Edge data { data: 'link2' } b
35.425 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.425 : INFO :  Edge is  { v: 'd', w: 'e', name: '2' }
35.425 : INFO :  Copying as  d e { data: 'link2' } 2
35.425 : INFO :  newGraph edges  [ { v: 'c', w: 'd', name: '2' }, { v: 'd', w: 'e', name: '2' } ] { data: 'link2' }
35.425 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
35.425 : INFO :  Edge data { data: 'link1' } b
35.425 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.425 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
35.425 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
35.425 : DEBUG :  Removing node d
35.425 : INFO :  cp  e  to  b  with parent  b
35.425 : INFO :  In copy  b root b data { data: 2 } b
35.425 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
35.425 : DEBUG :  Copying Edges [ { v: 'a', w: 'b', name: '1' } ]
35.425 : INFO :  Edge { v: 'a', w: 'b', name: '1' }
35.425 : INFO :  Edge data { data: 'link1' } b
35.425 : INFO :  Descendants of  b  is  [ 'c', 'd', 'e' ]
35.425 : INFO :  Edge is  { v: 'a', w: 'b', name: '1' }
35.425 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
35.425 : DEBUG :  Removing node e
35.425 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] }, { v: 'b', value: [Object] } ],
  edges: [ { v: 'a', w: 'b', name: '1', value: [Object] } ],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.425 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
35.425 : DEBUG :  Not a cluster c 0
35.425 : DEBUG :  Extracting node d {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
35.425 : DEBUG :  Not a cluster d 0
35.425 : DEBUG :  Extracting node e {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'b', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'b', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } }
} undefined true undefined undefined  Depth  0
35.425 : DEBUG :  Not a cluster e 0
35.425 : DEBUG :  Done, no node has children [ 'c', 'd', 'e' ]
35.425 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object] },
    { v: 'd', value: [Object] },
    { v: 'e', value: [Object] }
  ],
  edges: [
    { v: 'c', w: 'd', name: '2', value: [Object] },
    { v: 'd', w: 'e', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
35.426 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'a', value: [Object] },
    { v: 'b', value: [Object], parent: 'a' },
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'e', value: [Object], parent: 'c' }
  ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.426 : DEBUG :  Opting in, graph 
35.426 : DEBUG :  Cluster identified a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.426 : DEBUG :  Cluster identified b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.426 : DEBUG :  Cluster identified c {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.426 : DEBUG :  Not a cluster  e {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'a' ],
  B: [ 'b' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.426 : DEBUG :  Nodes =  [ 'a', 'b', 'c', 'e' ] 0
35.426 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true { data: 1 } undefined  Depth  0
35.426 : INFO :  cp  e  to  a  with parent  c
35.426 : DEBUG :  Setting parent e c
35.426 : DEBUG :  Copying Edges []
35.426 : DEBUG :  Removing node e
35.426 : INFO :  cp  c  to  a  with parent  c
35.426 : INFO :  In copy  c root a data { data: 3 } a
35.426 : DEBUG :  Not Setting parent for node= c cluster!==rootId true node!==clusterId false
35.426 : DEBUG :  Copying Edges []
35.426 : DEBUG :  Removing node c
35.426 : DEBUG :  Removing node c
35.426 : INFO :  cp  b  to  a  with parent  b
35.426 : INFO :  In copy  b root a data { data: 2 } a
35.426 : DEBUG :  Not Setting parent for node= b cluster!==rootId true node!==clusterId false
35.426 : DEBUG :  Copying Edges []
35.426 : DEBUG :  Removing node b
35.426 : DEBUG :  Removing node b
35.426 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'a', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 }
}
35.426 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.426 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.426 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.426 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.426 : DEBUG :  Extracting node e {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} undefined true undefined undefined  Depth  0
35.426 : DEBUG :  Not a cluster e 0
35.426 : DEBUG :  Nodes =  [ 'e', 'c', 'b' ] 1
35.426 : DEBUG :  Extracting node e {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} undefined false { data: 3 } undefined  Depth  1
35.426 : DEBUG :  Not a cluster e 1
35.426 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true false { data: 3 } undefined  Depth  1
35.426 : INFO :  cp  e  to  c  with parent  c
35.426 : INFO :  In copy  c root c data { data: 3 } c
35.426 : DEBUG :  Not Setting parent for node= e cluster!==rootId false node!==clusterId true
35.426 : DEBUG :  Copying Edges []
35.426 : DEBUG :  Removing node e
35.426 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'b' },
    { v: 'b', value: [Object] }
  ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.426 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'B', clusterData: undefined },
  A: { id: 'a', clusterData: { data: 6 } },
  B: { id: 'a', clusterData: { data: 4 } },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'a', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true { data: 2 } undefined  Depth  1
35.426 : INFO :  cp  c  to  b  with parent  b
35.426 : INFO :  In copy  b root b data { data: 2 } b
35.426 : DEBUG :  Not Setting parent for node= c cluster!==rootId false node!==clusterId true
35.426 : DEBUG :  Copying Edges []
35.426 : DEBUG :  Removing node c
35.426 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.426 : DEBUG :  Done, no node has children [ 'c' ]
35.426 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'b', value: [Object] } ],
  edges: [],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
35.427 : INFO :  Graph before {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object], parent: 'A' },
    { v: 'b', value: [Object], parent: 'A' },
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'a', value: [Object], parent: 'A' }
  ],
  edges: [
    { v: 'b', w: 'B', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.427 : DEBUG :  Opting in, graph 
35.427 : DEBUG :  Cluster identified A {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.427 : DEBUG :  Cluster identified B {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.427 : DEBUG :  Not a cluster  b {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.427 : DEBUG :  Not a cluster  c {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.427 : DEBUG :  Not a cluster  a {
  C1: [ 'a' ],
  C2: [ 'b' ],
  A: [ 'B', 'b', 'a', 'c' ],
  B: [ 'c' ],
  C: [ 'D', 'd' ],
  D: [ 'd' ],
  b: [ 'c', 'e' ],
  a: [ 'b', 'c', 'e' ],
  c: [ 'e' ]
}
35.427 : DEBUG :  Nodes =  [ 'A', 'B', 'b', 'c', 'a' ] 0
35.427 : DEBUG :  Extracting node A {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  0
35.427 : INFO :  cp  c  to  A  with parent  B
35.427 : DEBUG :  Setting parent c B
35.427 : DEBUG :  Copying Edges [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ]
35.427 : INFO :  Edge { v: 'b', w: 'c', name: '1' }
35.427 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} A
35.427 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
35.427 : INFO :  Edge is  { v: 'b', w: 'c', name: '1' }
35.427 : INFO :  Copying as  b c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
} 1
35.427 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
35.427 : INFO :  Edge { v: 'a', w: 'c', name: '2' }
35.427 : INFO :  Edge data {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  classes: 'flowchart-link LS-a LE-c'
} A
35.427 : INFO :  Descendants of  A  is  [ 'B', 'b', 'a', 'c' ]
35.427 : INFO :  Edge is  { v: 'a', w: 'c', name: '2' }
35.427 : INFO :  Copying as  a c {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-a-c',
  classes: 'flowchart-link LS-a LE-c'
} 2
35.427 : INFO :  newGraph edges  [ { v: 'b', w: 'c', name: '1' }, { v: 'a', w: 'c', name: '2' } ] {
  minlen: 1,
  arrowhead: 'normal',
  arrowTypeStart: 'arrow_open',
  arrowTypeEnd: 'arrow_point',
  thickness: 'normal',
  pattern: 'solid',
  style: 'fill:none',
  labelStyle: '',
  arrowheadStyle: 'fill: #333',
  labelpos: 'c',
  labelType: 'text',
  label: '',
  id: 'L-b-B',
  classes: 'flowchart-link LS-b LE-B',
  toCluster: 'B'
}
35.427 : DEBUG :  Removing node c
35.427 : INFO :  cp  B  to  A  with parent  B
35.427 : INFO :  In copy  B root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} A
35.427 : DEBUG :  Not Setting parent for node= B cluster!==rootId true node!==clusterId false
35.427 : DEBUG :  Copying Edges []
35.427 : DEBUG :  Removing node B
35.427 : DEBUG :  Removing node B
35.427 : INFO :  cp  b  to  A  with parent  A
35.427 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
35.427 : DEBUG :  Not Setting parent for node= b cluster!==rootId false node!==clusterId true
35.427 : DEBUG :  Copying Edges []
35.427 : DEBUG :  Removing node b
35.427 : INFO :  cp  a  to  A  with parent  A
35.427 : INFO :  In copy  A root A data {
  labelStyle: '',
  shape: 'rect',
  labelText: 'A',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'A',
  width: 500,
  type: 'group',
  padding: 15
} A
35.427 : DEBUG :  Not Setting parent for node= a cluster!==rootId false node!==clusterId true
35.427 : DEBUG :  Copying Edges []
35.427 : DEBUG :  Removing node a
35.427 : DEBUG :  Old graph after copy {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [ { v: 'A', value: [Object] } ],
  edges: [],
  value: { rankdir: 'TB', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}
35.427 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} false true undefined undefined  Depth  0
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true undefined undefined  Depth  0
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : DEBUG :  Nodes =  [ 'c', 'B', 'b', 'a' ] 1
35.427 : DEBUG :  Extracting node c {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true false {
  labelStyle: '',
  shape: 'rect',
  labelText: 'c',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'c',
  padding: 15
} undefined  Depth  1
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : DEBUG :  Extracting node B {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} false true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'B',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'B',
  width: 500,
  type: 'group',
  padding: 15
} undefined  Depth  1
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : DEBUG :  Extracting node b {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'b',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'b',
  padding: 15
} undefined  Depth  1
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : DEBUG :  Extracting node a {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
} true true {
  labelStyle: '',
  shape: 'rect',
  labelText: 'a',
  rx: 0,
  ry: 0,
  class: 'default',
  style: '',
  id: 'a',
  padding: 15
} undefined  Depth  1
35.427 : DEBUG :  {
  C1: { id: 'A', clusterData: { data: 4 } },
  C2: { id: 'A', clusterData: undefined },
  A: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'A',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'A',
      width: 500,
      type: 'group',
      padding: 15
    }
  },
  B: {
    id: 'c',
    clusterData: {
      labelStyle: '',
      shape: 'rect',
      labelText: 'B',
      rx: 0,
      ry: 0,
      class: 'default',
      style: '',
      id: 'B',
      width: 500,
      type: 'group',
      padding: 15
    },
    externalConnections: true
  },
  C: { id: 'D', clusterData: { data: 1 } },
  D: { id: 'A', clusterData: { data: 2 } },
  b: { id: 'c', clusterData: { data: 2 } },
  a: { id: 'c', clusterData: { data: 1 } },
  c: { id: 'e', clusterData: { data: 3 } }
}
35.427 : INFO :  Graph after {
  options: { directed: true, multigraph: true, compound: true },
  nodes: [
    { v: 'c', value: [Object], parent: 'B' },
    { v: 'B', value: [Object] },
    { v: 'b', value: [Object] },
    { v: 'a', value: [Object] }
  ],
  edges: [
    { v: 'b', w: 'c', name: '1', value: [Object] },
    { v: 'a', w: 'c', name: '2', value: [Object] }
  ],
  value: { rankdir: 'LR', nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 }
}

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with a node
. 
          
Lex: NODE_ID id
. 
      
Lex: EOF 
Rule: node (NODE_ID separator):  id
Rule: nodeStatement (node)  { id: 'id' }
Rule: statement:  {
  id: 'id',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a node with a square shape and a label
. 
          
Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: EOF 
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: '[]', label: 'A label' }
Rule: nodeStatement (node)  { id: 'id', label: 'A label', typeStr: '[]', directions: undefined }
Rule: statement:  {
  id: 'id',
  label: 'A label',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id',
    label: 'A label',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes
. 
          
Lex: NODE_ID id1
. 
          
Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: 'id1' }
. 
      
Lex: EOF 
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: 'id2' }
Rule: statement:  {
  id: 'id2',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id1',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id1',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id2',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes
. 
          
Lex: NODE_ID id1
. 
          
Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: 'id1' }
. 
          
Lex: NODE_ID id3
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: 'id2' }
. 
      
Lex: EOF 
Rule: node (NODE_ID separator):  id3
Rule: nodeStatement (node)  { id: 'id3' }
Rule: statement:  {
  id: 'id3',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id2',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id1',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id1',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id2',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id3',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a node with a square shape and a label
. 
          
Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: NODE_ID id2
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: '[]', label: 'A label' }
Rule: nodeStatement (node)  { id: 'id', label: 'A label', typeStr: '[]', directions: undefined }
Lex: EOF 
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: 'id2' }
Rule: statement:  {
  id: 'id2',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id',
  label: 'A label',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'id',
    label: 'A label',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id2',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
. 
          
Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.   
Lex: LINK #-->   #
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: '[]', label: 'first' }
Rule: nodeStatement (node)  { id: 'id1', label: 'first', typeStr: '[]', directions: undefined }
Rule: link:  -->    -->   
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: '[]', label: 'second' }
Rule: (nodeStatement link node)  {
  id: 'id1',
  label: 'first',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
} { edgeTypeStr: '-->   ', label: '' } { id: 'id2', label: 'second', typeStr: '[]', directions: undefined }  typestr:  -->   
Rule: statement:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: '',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]
Rule: hierarchy:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: '',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
. 
          
Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.   
Lex: START_LINK -- 
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: '[]', label: 'first' }
Rule: nodeStatement (node)  { id: 'id1', label: 'first', typeStr: '[]', directions: undefined }
Lex: Starting string
LEX: STR end: a label
LEX: POPPING STR: "
Lex: LINK # -->   #
Rule: LABEL link:  --  a label  -->   
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: '[]', label: 'second' }
Rule: (nodeStatement link node)  {
  id: 'id1',
  label: 'first',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
} { edgeTypeStr: ' -->   ', label: 'a label' } { id: 'id2', label: 'second', typeStr: '[]', directions: undefined }  typestr:   -->   
Rule: statement:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: 'a label',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]
Rule: hierarchy:  [
  { id: 'id1', label: 'first', type: 'square', directions: undefined },
  {
    id: 'id1-id2',
    start: 'id1',
    end: 'id2',
    label: 'a label',
    type: 'edge',
    directions: undefined,
    arrowTypeEnd: 'arrow_point',
    arrowTypeStart: 'arrow_open'
  },
  { id: 'id2', label: 'second', type: 'square', directions: undefined }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with column statements
. 
          
COLUMNS (LEX) 2
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '2',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 2 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 2 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram withput column statements
. 
          
Lex: NODE_ID block1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > a diagram with auto column statements
. 
          
. 
          
Lex: NODE_ID block1
APA123 {
  '$': -1,
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 22 }
}
COLUMNS:  -1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
      
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: -1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: -1 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks next to each other
. 
          
COLUMNS (LEX) 2
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '2',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 2 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 2 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks on top of each other
. 
          
COLUMNS (LEX) 1
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
          
Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > compound blocks 2
. 
          
Found space-block
Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
. 
            
Lex: NODE_ID bBlock
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: '[]', label: 'ABlock' }
Rule: nodeStatement (node)  { id: 'aBlock', label: 'ABlock', typeStr: '[]', directions: undefined }
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
. 
          
Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: '[]', label: 'BBlock' }
Rule: nodeStatement (node)  { id: 'bBlock', label: 'BBlock', typeStr: '[]', directions: undefined }
Rule: statement:  {
  id: 'bBlock',
  label: 'BBlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'aBlock',
  label: 'ABlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Lex: EOF 
Rule: blockStatement :  block
             [
  {
    id: 'aBlock',
    label: 'ABlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'bBlock',
    label: 'BBlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
] end
        
Rule: statement:  {
  id: 'id-hu6eamvwhj8-1',
  type: 'composite',
  label: '',
  children: [
    {
      id: 'aBlock',
      label: 'ABlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'bBlock',
      label: 'BBlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: hierarchy:  [
  {
    id: 'id-hu6eamvwhj8-1',
    type: 'composite',
    label: '',
    children: [ [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > compound blocks of compound blocks
. 
          
Found space-block
Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
. 
            
Found space-block
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: '[]', label: 'ABlock' }
Rule: nodeStatement (node)  { id: 'aBlock', label: 'ABlock', typeStr: '[]', directions: undefined }
Lex: NODE_ID bBlock
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
. 
            
Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: '[]', label: 'BBlock' }
Rule: nodeStatement (node)  { id: 'bBlock', label: 'BBlock', typeStr: '[]', directions: undefined }
Rule: statement:  {
  id: 'bBlock',
  label: 'BBlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: blockStatement :  block
               [
  {
    id: 'bBlock',
    label: 'BBlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
] end
          
Rule: statement:  {
  id: 'id-bauhrdrbjab-2',
  type: 'composite',
  label: '',
  children: [
    {
      id: 'bBlock',
      label: 'BBlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: statement #2:  {
  id: 'aBlock',
  label: 'ABlock',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Lex: EOF 
Rule: blockStatement :  block
             [
  {
    id: 'aBlock',
    label: 'ABlock',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id-bauhrdrbjab-2',
    type: 'composite',
    label: '',
    children: [ [Object] ]
  }
] end
        
Rule: statement:  {
  id: 'id-91fqdxoqkn9-3',
  type: 'composite',
  label: '',
  children: [
    {
      id: 'aBlock',
      label: 'ABlock',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'id-bauhrdrbjab-2',
      type: 'composite',
      label: '',
      children: [Array]
    }
  ]
}
Rule: hierarchy:  [
  {
    id: 'id-91fqdxoqkn9-3',
    type: 'composite',
    label: '',
    children: [ [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > compound blocks with title
. 
          
Found space-block
Lex: NODE_ID compoundBlock
Lexa: [
Lex: Starting string
LEX: STR end: Compound block
LEX: POPPING STR: "
Lex: ]
. 
            
COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ Compound block ]
Rule: node (NODE_ID nodeShapeNLabel separator):  compoundBlock { typeStr: '[]', label: 'Compound block' }
Rule: nodeStatement (node)  {
  id: 'compoundBlock',
  label: 'Compound block',
  typeStr: '[]',
  directions: undefined
}
. 
            
Lex: NODE_ID block2
APA123 {
  '$': '1',
  '_$': { first_line: 3, last_line: 3, first_column: 12, last_column: 21 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
          
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Lex: EOF 
Rule: id-block statement :  {
  id: 'compoundBlock',
  label: 'Compound block',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
} [
  { type: 'column-setting', columns: 1 },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]
Rule: statement:  {
  id: 'compoundBlock',
  label: 'Compound block',
  type: 'composite',
  directions: undefined,
  widthInColumns: 1,
  children: [
    { type: 'column-setting', columns: 1 },
    {
      id: 'block2',
      label: 'Block 2',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: hierarchy:  [
  {
    id: 'compoundBlock',
    label: 'Compound block',
    type: 'composite',
    directions: undefined,
    widthInColumns: 1,
    children: [ [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks mixed with compound blocks
. 
          
COLUMNS (LEX) 1
. 
          
Lex: NODE_ID block1
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 10, last_column: 19 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 

          
Found space-block
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
COLUMNS (LEX) 2
. 
            
Lex: NODE_ID block2
APA123 {
  '$': '2',
  '_$': { first_line: 6, last_line: 6, first_column: 12, last_column: 21 }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
. 
            
Lex: NODE_ID block3
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 3
LEX: POPPING STR: "
Lex: ]
. 
          
Rule: nodeShapeNLabel:  [ Block 3 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block3 { typeStr: '[]', label: 'Block 3' }
Rule: nodeStatement (node)  {
  id: 'block3',
  label: 'Block 3',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block3',
  label: 'Block 3',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 2 }
Lex: EOF 
Rule: blockStatement :  block
             [
  { type: 'column-setting', columns: 2 },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'block3',
    label: 'Block 3',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
] end
        
Rule: statement:  {
  id: 'id-4aaeebuqpci-5',
  type: 'composite',
  label: '',
  children: [
    { type: 'column-setting', columns: 2 },
    {
      id: 'block2',
      label: 'Block 2',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'block3',
      label: 'Block 3',
      type: 'square',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id-4aaeebuqpci-5',
    type: 'composite',
    label: '',
    children: [ [Object], [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > Arrow blocks
. 
        
COLUMNS (LEX) 3
. 
        
Lex: NODE_ID block1
APA123 {
  '$': '3',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: NODE_ID blockArrow
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: '[]', label: 'Block 1' }
Rule: nodeStatement (node)  {
  id: 'block1',
  label: 'Block 1',
  typeStr: '[]',
  directions: undefined
}
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (right): dir: right
Lex (ARROW_DIR end): ]>
Rule: dirList:  right
Lex: NODE_ID block2
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ 'right' ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: '<[]>',
  label: '&nbsp;&nbsp;&nbsp;',
  directions: [ 'right' ]
}
Rule: nodeStatement (node)  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  typeStr: '<[]>',
  directions: [ 'right' ]
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
Lex: EOF 
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: '[]', label: 'Block 2' }
Rule: nodeStatement (node)  {
  id: 'block2',
  label: 'Block 2',
  typeStr: '[]',
  directions: undefined
}
Rule: statement:  {
  id: 'block2',
  label: 'Block 2',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  type: 'block_arrow',
  directions: [ 'right' ],
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'block1',
  label: 'Block 1',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 3 },
  {
    id: 'block1',
    label: 'Block 1',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'blockArrow',
    label: '&nbsp;&nbsp;&nbsp;',
    type: 'block_arrow',
    directions: [ 'right' ],
    widthInColumns: 1
  },
  {
    id: 'block2',
    label: 'Block 2',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > Arrow blocks with multiple points
. 
        
COLUMNS (LEX) 1
. 
        
Lex: NODE_ID A
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  1
. 
        
Lex: NODE_ID blockArrow
Rule: node (NODE_ID separator):  A
Rule: nodeStatement (node)  { id: 'A' }
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (up): up
Lex (down): down
Lex (ARROW_DIR end): ]>
Rule: dirList:  down
Rule: dirList:  up [ 'down' ]
Found space-block
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ 'up', 'down' ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: '<[]>',
  label: '&nbsp;&nbsp;&nbsp;',
  directions: [ 'up', 'down' ]
}
Rule: nodeStatement (node)  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  typeStr: '<[]>',
  directions: [ 'up', 'down' ]
}
COLUMNS (LEX) 3
. 
            
Lex: NODE_ID B
APA123 {
  '$': '3',
  '_$': { first_line: 6, last_line: 6, first_column: 10, last_column: 19 }
}
COLUMNS:  3
. 
            
Lex: NODE_ID C
Rule: node (NODE_ID separator):  B
Rule: nodeStatement (node)  { id: 'B' }
. 
            
Lex: NODE_ID D
Rule: node (NODE_ID separator):  C
Rule: nodeStatement (node)  { id: 'C' }
. 
        
Rule: node (NODE_ID separator):  D
Rule: nodeStatement (node)  { id: 'D' }
Rule: statement:  {
  id: 'D',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'C',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'B',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Lex: EOF 
Rule: blockStatement :  block
           [
  { type: 'column-setting', columns: 3 },
  {
    id: 'B',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'C',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'D',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
] end
Rule: statement:  {
  id: 'id-2a7nzaj262r-6',
  type: 'composite',
  label: '',
  children: [
    { type: 'column-setting', columns: 3 },
    {
      id: 'B',
      label: undefined,
      type: 'na',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'C',
      label: undefined,
      type: 'na',
      directions: undefined,
      widthInColumns: 1
    },
    {
      id: 'D',
      label: undefined,
      type: 'na',
      directions: undefined,
      widthInColumns: 1
    }
  ]
}
Rule: statement #2:  {
  id: 'blockArrow',
  label: '&nbsp;&nbsp;&nbsp;',
  type: 'block_arrow',
  directions: [ 'up', 'down' ],
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'A',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'A',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'blockArrow',
    label: '&nbsp;&nbsp;&nbsp;',
    type: 'block_arrow',
    directions: [ 'up', 'down' ],
    widthInColumns: 1
  },
  {
    id: 'id-2a7nzaj262r-6',
    type: 'composite',
    label: '',
    children: [ [Object], [Object], [Object], [Object] ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > blocks with different widths
. 
        
COLUMNS (LEX) 3
. 
        
Lex: NODE_ID one
APA123 {
  '$': '3',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: One Slot
LEX: POPPING STR: "
Lex: ]
. 
        
Lex: NODE_ID two
Rule: nodeShapeNLabel:  [ One Slot ]
Rule: node (NODE_ID nodeShapeNLabel separator):  one { typeStr: '[]', label: 'One Slot' }
Rule: nodeStatement (node)  { id: 'one', label: 'One Slot', typeStr: '[]', directions: undefined }
Lexa: [
Lex: Starting string
LEX: STR end: Two slots
LEX: POPPING STR: "
Lex: ]
Lex: COLON :2
Rule: nodeShapeNLabel:  [ Two slots ]
Rule: node (NODE_ID nodeShapeNLabel separator):  two { typeStr: '[]', label: 'Two slots' }
. 
        
Lex: EOF 
Rule: nodeStatement (abc88 node size)  { id: 'two', label: 'Two slots', typeStr: '[]', directions: undefined } 2
Rule: statement:  {
  id: 'two',
  label: 'Two slots',
  type: 'square',
  directions: undefined,
  widthInColumns: 2
}
Rule: statement #2:  {
  id: 'one',
  label: 'One Slot',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 3 },
  {
    id: 'one',
    label: 'One Slot',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'two',
    label: 'Two slots',
    type: 'square',
    directions: undefined,
    widthInColumns: 2
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > empty blocks
. 
        
COLUMNS (LEX) 3
. 
        
COLUMNS (LEX) 1
APA123 {
  '$': '3',
  '_$': { first_line: 2, last_line: 2, first_column: 8, last_column: 17 }
}
COLUMNS:  3
. 
        
Lex: NODE_ID middle
Lexa: [
Lex: Starting string
LEX: STR end: In the middle
LEX: POPPING STR: "
Lex: ]
. 
        
COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ In the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  middle { typeStr: '[]', label: 'In the middle' }
Rule: nodeStatement (node)  {
  id: 'middle',
  label: 'In the middle',
  typeStr: '[]',
  directions: undefined
}
. 
        
Lex: EOF 
Rule: statement:  {
  id: 'id-7x563swjfgl-8',
  type: 'space',
  label: '',
  width: 1,
  children: []
}
Rule: statement #2:  {
  id: 'middle',
  label: 'In the middle',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  {
  id: 'id-o8uw0agkafo-7',
  type: 'space',
  label: '',
  width: 1,
  children: []
}
Rule: statement #2:  { type: 'column-setting', columns: 3 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 3 },
  {
    id: 'id-o8uw0agkafo-7',
    type: 'space',
    label: '',
    width: 1,
    children: []
  },
  {
    id: 'middle',
    label: 'In the middle',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    id: 'id-7x563swjfgl-8',
    type: 'space',
    label: '',
    width: 1,
    children: []
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > classDef statements applied to a block
. 
        
. 

        
Lex: NODE_ID mc
Lexa: [
Lex: Starting string
LEX: STR end: Memcache
LEX: POPPING STR: "
Lex: ]
. 
        
Rule: nodeShapeNLabel:  [ Memcache ]
Rule: node (NODE_ID nodeShapeNLabel separator):  mc { typeStr: '[]', label: 'Memcache' }
Rule: nodeStatement (node)  { id: 'mc', label: 'Memcache', typeStr: '[]', directions: undefined }
. 
        
Lex: EOF 
Rule: statement:  { type: 'applyClass', id: 'mc', styleClass: 'black' }
Rule: statement #2:  {
  id: 'mc',
  label: 'Memcache',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'classDef', id: 'black', css: 'color:#ffffff, fill:#000000;' }
Rule: hierarchy:  [
  {
    type: 'classDef',
    id: 'black',
    css: 'color:#ffffff, fill:#000000;'
  },
  {
    id: 'mc',
    label: 'Memcache',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  { type: 'applyClass', id: 'mc', styleClass: 'black' }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing an block diagram graph it should handle >  > style statements applied to a block
. 

COLUMNS (LEX) 1
. 
    
Lex: NODE_ID B
APA123 {
  '$': '1',
  '_$': { first_line: 2, last_line: 2, first_column: 0, last_column: 9 }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: A wide one in the middle
LEX: POPPING STR: "
Lex: ]
. 
  
Rule: nodeShapeNLabel:  [ A wide one in the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  B { typeStr: '[]', label: 'A wide one in the middle' }
Rule: nodeStatement (node)  {
  id: 'B',
  label: 'A wide one in the middle',
  typeStr: '[]',
  directions: undefined
}
. 
        
Lex: EOF 
Rule: statement:  {
  type: 'applyStyles',
  id: 'B',
  stylesStr: 'fill:#f9F,stroke:#333,stroke-width:4px'
}
Rule: statement #2:  {
  id: 'B',
  label: 'A wide one in the middle',
  type: 'square',
  directions: undefined,
  widthInColumns: 1
}
Rule: statement #2:  { type: 'column-setting', columns: 1 }
Rule: hierarchy:  [
  { type: 'column-setting', columns: 1 },
  {
    id: 'B',
    label: 'A wide one in the middle',
    type: 'square',
    directions: undefined,
    widthInColumns: 1
  },
  {
    type: 'applyStyles',
    id: 'B',
    stylesStr: 'fill:#f9F,stroke:#333,stroke-width:4px'
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a __proto__ property
. 

Lex: NODE_ID __proto__
Lex: EOF 
Rule: node (NODE_ID separator):  __proto__
Rule: nodeStatement (node)  { id: '__proto__' }
Rule: statement:  {
  id: '__proto__',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: '__proto__',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]
. 

Lex: NODE_ID A;
.  
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: 'A;' }
Lex: EOF 
Rule: statement:  {
  type: 'classDef',
  id: '__proto__',
  css: 'color:#ffffff,fill:#000000; class A __proto__'
}
Rule: statement #2:  {
  id: 'A;',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'A;',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    type: 'classDef',
    id: '__proto__',
    css: 'color:#ffffff,fill:#000000; class A __proto__'
  }
]

 ✓ packages/mermaid/src/diagrams/block/parser/block.spec.ts  (24 tests) 29ms
stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a constructor property
. 

Lex: NODE_ID constructor
Lex: EOF 
Rule: node (NODE_ID separator):  constructor
Rule: nodeStatement (node)  { id: 'constructor' }
Rule: statement:  {
  id: 'constructor',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'constructor',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  }
]
. 

Lex: NODE_ID A;
.  
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: 'A;' }
Lex: EOF 
Rule: statement:  {
  type: 'classDef',
  id: 'constructor',
  css: 'color:#ffffff,fill:#000000; class A constructor'
}
Rule: statement #2:  {
  id: 'A;',
  label: undefined,
  type: 'na',
  directions: undefined,
  widthInColumns: 1
}
Rule: hierarchy:  [
  {
    id: 'A;',
    label: undefined,
    type: 'na',
    directions: undefined,
    widthInColumns: 1
  },
  {
    type: 'classDef',
    id: 'constructor',
    css: 'color:#ffffff,fill:#000000; class A constructor'
  }
]

stdout | packages/mermaid/src/mermaidAPI.spec.ts > mermaidAPI > render > accessibility > gitGraph > should set aria-roledescription to the diagram type AND should call addSVGa11yTitleDescription
Ambiguous Alternatives Detected: <0, 0, 1, 1, 0, 1> in <MANY2> inside <GitGraph​> Rule,
<NEWLINE, ACC_TITLE, NEWLINE> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.

 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-style.spec.js  (24 tests) 16ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-singlenode.spec.js  (148 tests) 67ms
stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-1 should handle a simple root definition abc122
35.783 : INFO :  Node:  root
35.783 : INFO :  addNode 4 root root 0
35.783 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-2 should handle a hierachial mindmap definition
35.785 : INFO :  Node:  root
35.785 : INFO :  addNode 4 root root 0
35.785 : TRACE :  Stop NL 
35.785 : INFO :  Node:  child1
35.785 : INFO :  addNode 6 child1 child1 0
35.785 : TRACE :  Stop NL 
35.785 : INFO :  Node:  child2
35.785 : INFO :  addNode 6 child2 child2 0
35.785 : TRACE :  Stop NL 
35.785 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > 3 should handle a simple root definition with a shape and without an id abc123
35.787 : TRACE :  Long description: root
35.787 : TRACE :  node end )
35.787 : TRACE :  node found .. (
35.787 : DEBUG :  In get type ( )
35.787 : INFO :  Node:  root
35.787 : INFO :  addNode 4 root root 1
35.787 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-4 should handle a deeper hierachial mindmap definition
35.789 : INFO :  Node:  root
35.789 : INFO :  addNode 4 root root 0
35.789 : TRACE :  Stop NL 
35.789 : INFO :  Node:  child1
35.789 : INFO :  addNode 6 child1 child1 0
35.789 : TRACE :  Stop NL 
35.789 : INFO :  Node:  leaf1
35.789 : INFO :  addNode 8 leaf1 leaf1 0
35.789 : TRACE :  Stop NL 
35.789 : INFO :  Node:  child2
35.789 : INFO :  addNode 6 child2 child2 0
35.789 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > 5 Multiple roots are illegal
35.790 : INFO :  Node:  root
35.790 : INFO :  addNode 4 root root 0
35.790 : TRACE :  Stop NL 
35.790 : INFO :  Node:  fakeRoot
35.790 : INFO :  addNode 4 fakeRoot fakeRoot 0

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hiearchy > MMP-6 real root in wrong place
35.791 : INFO :  Node:  root
35.791 : INFO :  addNode 10 root root 0
35.791 : TRACE :  Stop NL 
35.791 : INFO :  Node:  fakeRoot
35.791 : INFO :  addNode 8 fakeRoot fakeRoot 0

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-7 should handle an id and type for a node definition
35.791 : TRACE :  Long description: The root
35.791 : TRACE :  node end ... ]
35.791 : TRACE :  node found .. root
35.791 : DEBUG :  In get type [ ]
35.791 : INFO :  Node:  root
35.791 : INFO :  addNode 4 root The root 2
35.791 : TRACE :  Stop NL 
35.791 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-8 should handle an id and type for a node definition
35.791 : INFO :  Node:  root
35.791 : INFO :  addNode 4 root root 0
35.791 : TRACE :  Stop NL 
35.791 : TRACE :  Long description: child1
35.791 : TRACE :  node end )
35.791 : TRACE :  node found .. theId
35.791 : DEBUG :  In get type ( )
35.791 : INFO :  Node:  theId
35.791 : INFO :  addNode 6 theId child1 1
35.791 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-9 should handle an id and type for a node definition
35.792 : TRACE :  Node:  root
35.792 : INFO :  addNode 0 root root 0
35.792 : TRACE :  Stop NL 
35.792 : TRACE :  Long description: child1
35.792 : TRACE :  node end )
35.792 : TRACE :  node found .. theId
35.792 : DEBUG :  In get type ( )
35.792 : INFO :  Node:  theId
35.792 : INFO :  addNode 6 theId child1 1
35.792 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-10 multiple types (circle)
35.792 : TRACE :  Long description: the root
35.792 : TRACE :  node end ))
35.792 : TRACE :  node found .. root
35.792 : DEBUG :  In get type (( ))
35.792 : INFO :  Node:  root
35.792 : INFO :  addNode 1 root the root 3
35.792 : TRACE :  Stop NL 
35.792 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-11 multiple types (cloud)
35.793 : TRACE :  Cloud Bang
35.793 : TRACE :  Long description: the root
35.793 : TRACE :  node end ((
35.793 : TRACE :  node found .. root
35.793 : DEBUG :  In get type ) (
35.793 : INFO :  Node:  root
35.793 : INFO :  addNode 1 root the root 4
35.793 : TRACE :  Stop NL 
35.793 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12 multiple types (bang)
35.798 : TRACE :  Explosion Bang
35.798 : TRACE :  Long description: the root
35.798 : TRACE :  node end ((
35.798 : TRACE :  node found .. root
35.798 : DEBUG :  In get type )) ((
35.798 : INFO :  Node:  root
35.798 : INFO :  addNode 1 root the root 5
35.798 : TRACE :  Stop NL 
35.798 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12-a multiple types (hexagon)
35.798 : TRACE :  Long description: the root
35.798 : TRACE :  node end ((
35.798 : TRACE :  node found .. root
35.798 : DEBUG :  In get type {{ }}
35.798 : INFO :  Node:  root
35.798 : INFO :  addNode 1 root the root 6
35.798 : TRACE :  Stop NL 
35.798 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-13 should be possible to set an icon for the node
35.798 : TRACE :  Long description: The root
35.798 : TRACE :  node end ... ]
35.798 : TRACE :  node found .. root
35.798 : DEBUG :  In get type [ ]
35.798 : INFO :  Node:  root
35.798 : INFO :  addNode 4 root The root 2
35.798 : TRACE :  Stop NL 
35.798 : TRACE :  Begin icon
35.798 : TRACE :  end icon
35.798 : TRACE :  Icon:  bomb
35.798 : TRACE :  Stop NL 
35.798 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-14 should be possible to set classes for the node
35.799 : TRACE :  Long description: The root
35.799 : TRACE :  node end ... ]
35.799 : TRACE :  node found .. root
35.799 : DEBUG :  In get type [ ]
35.799 : INFO :  Node:  root
35.799 : INFO :  addNode 4 root The root 2
35.799 : TRACE :  Stop NL 
35.799 : TRACE :  Stop NL 
35.799 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-15 should be possible to set both classes and icon for the node
35.799 : TRACE :  Long description: The root
35.799 : TRACE :  node end ... ]
35.799 : TRACE :  node found .. root
35.799 : DEBUG :  In get type [ ]
35.799 : INFO :  Node:  root
35.799 : INFO :  addNode 4 root The root 2
35.799 : TRACE :  Stop NL 
35.799 : TRACE :  Stop NL 
35.799 : TRACE :  Begin icon
35.799 : TRACE :  end icon
35.799 : TRACE :  Icon:  bomb
35.799 : TRACE :  Stop NL 
35.799 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-16 should be possible to set both classes and icon for the node
35.800 : TRACE :  Long description: The root
35.800 : TRACE :  node end ... ]
35.800 : TRACE :  node found .. root
35.800 : DEBUG :  In get type [ ]
35.800 : INFO :  Node:  root
35.800 : INFO :  addNode 4 root The root 2
35.800 : TRACE :  Stop NL 
35.800 : TRACE :  Begin icon
35.800 : TRACE :  end icon
35.800 : TRACE :  Icon:  bomb
35.800 : TRACE :  Stop NL 
35.800 : TRACE :  Stop NL 
35.800 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-17 should be possible to use node syntax in the descriptions
35.800 : TRACE :  Starting NSTR
35.800 : TRACE :  description: String containing []
35.800 : TRACE :  node end ... ]
35.800 : TRACE :  node found .. root
35.800 : DEBUG :  In get type [ ]
35.800 : INFO :  Node:  root
35.800 : INFO :  addNode 4 root String containing [] 2
35.800 : TRACE :  Stop NL 
35.800 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-18 should be possible to use node syntax in the descriptions in children
35.800 : TRACE :  Starting NSTR
35.800 : TRACE :  description: String containing []
35.800 : TRACE :  node end ... ]
35.800 : TRACE :  node found .. root
35.800 : DEBUG :  In get type [ ]
35.800 : INFO :  Node:  root
35.800 : INFO :  addNode 4 root String containing [] 2
35.800 : TRACE :  Stop NL 
35.800 : TRACE :  Starting NSTR
35.800 : TRACE :  description: String containing ()
35.800 : TRACE :  node end ... ]
35.800 : TRACE :  node found .. child1
35.800 : DEBUG :  In get type [ ]
35.800 : INFO :  Node:  child1
35.800 : INFO :  addNode 6 child1 String containing () 2
35.800 : TRACE :  Stop NL 
35.800 : TRACE :  Stop EOF2 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-19 should be possible to have a child after a class assignment
35.801 : TRACE :  Long description: Root
35.801 : TRACE :  node end )
35.801 : TRACE :  node found .. root
35.801 : DEBUG :  In get type ( )
35.801 : INFO :  Node:  root
35.801 : INFO :  addNode 2 root Root 1
35.801 : TRACE :  Stop NL 
35.801 : TRACE :  Long description: Child
35.801 : TRACE :  node end )
35.801 : TRACE :  node found .. Child
35.801 : DEBUG :  In get type ( )
35.801 : INFO :  Node:  Child
35.801 : INFO :  addNode 4 Child Child 1
35.801 : TRACE :  Stop NL 
35.801 : TRACE :  Stop NL 
35.801 : TRACE :  Long description: a
35.801 : TRACE :  node end )
35.801 : TRACE :  node found .. a
35.801 : DEBUG :  In get type ( )
35.801 : INFO :  Node:  a
35.801 : INFO :  addNode 6 a a 1
35.801 : TRACE :  Stop NL 
35.801 : TRACE :  Long description: New Stuff
35.801 : TRACE :  node end ... ]
35.801 : TRACE :  node found .. b
35.801 : DEBUG :  In get type [ ]
35.801 : INFO :  Node:  b
35.801 : INFO :  addNode 6 b New Stuff 2
35.801 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-20 should be possible to have meaningless empty rows in a mindmap abc124
35.801 : TRACE :  Long description: Root
35.801 : TRACE :  node end )
35.801 : TRACE :  node found .. root
35.801 : DEBUG :  In get type ( )
35.801 : INFO :  Node:  root
35.801 : INFO :  addNode 2 root Root 1
35.801 : TRACE :  Stop NL 
35.801 : TRACE :  Long description: Child
35.801 : TRACE :  node end )
35.801 : TRACE :  node found .. Child
35.801 : DEBUG :  In get type ( )
35.801 : INFO :  Node:  Child
35.801 : INFO :  addNode 4 Child Child 1
35.801 : TRACE :  Stop NL 
35.801 : TRACE :  Long description: a
35.801 : TRACE :  node end )
35.801 : TRACE :  SPACELINE
35.801 : TRACE :  node found .. a
35.801 : DEBUG :  In get type ( )
35.801 : INFO :  Node:  a
35.801 : INFO :  addNode 6 a a 1
35.801 : TRACE :  Long description: New Stuff
35.801 : TRACE :  node end ... ]
35.801 : TRACE :  node found .. b
35.801 : DEBUG :  In get type [ ]
35.801 : INFO :  Node:  b
35.801 : INFO :  addNode 6 b New Stuff 2
35.801 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-21 should be possible to have comments in a mindmap
35.802 : TRACE :  Long description: Root
35.802 : TRACE :  node end )
35.802 : TRACE :  node found .. root
35.802 : DEBUG :  In get type ( )
35.802 : INFO :  Node:  root
35.802 : INFO :  addNode 2 root Root 1
35.802 : TRACE :  Stop NL 
35.802 : TRACE :  Long description: Child
35.802 : TRACE :  node end )
35.802 : TRACE :  node found .. Child
35.802 : DEBUG :  In get type ( )
35.802 : INFO :  Node:  Child
35.802 : INFO :  addNode 4 Child Child 1
35.802 : TRACE :  Stop NL 
35.802 : TRACE :  Long description: a
35.802 : TRACE :  node end )
35.802 : TRACE :  Found comment 

      %% This is a comment
35.802 : TRACE :  node found .. a
35.802 : DEBUG :  In get type ( )
35.802 : INFO :  Node:  a
35.802 : INFO :  addNode 6 a a 1
35.802 : TRACE :  Stop NL2 
35.802 : TRACE :  Long description: New Stuff
35.802 : TRACE :  node end ... ]
35.802 : TRACE :  node found .. b
35.802 : DEBUG :  In get type [ ]
35.802 : INFO :  Node:  b
35.802 : INFO :  addNode 6 b New Stuff 2
35.802 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-22 should be possible to have comments at the end of a line
35.803 : TRACE :  Long description: Root
35.803 : TRACE :  node end )
35.803 : TRACE :  node found .. root
35.803 : DEBUG :  In get type ( )
35.803 : INFO :  Node:  root
35.803 : INFO :  addNode 2 root Root 1
35.803 : TRACE :  Stop NL 
35.803 : TRACE :  Long description: Child
35.803 : TRACE :  node end )
35.803 : TRACE :  node found .. Child
35.803 : DEBUG :  In get type ( )
35.803 : INFO :  Node:  Child
35.803 : INFO :  addNode 4 Child Child 1
35.803 : TRACE :  Stop NL 
35.803 : TRACE :  Long description: a
35.803 : TRACE :  node end )
35.803 : TRACE :  Found comment  %% This is a comment
35.803 : TRACE :  node found .. a
35.803 : DEBUG :  In get type ( )
35.803 : INFO :  Node:  a
35.803 : INFO :  addNode 6 a a 1
35.803 : TRACE :  Stop NL2 
35.803 : TRACE :  Long description: New Stuff
35.803 : TRACE :  node end ... ]
35.803 : TRACE :  node found .. b
35.803 : DEBUG :  In get type [ ]
35.803 : INFO :  Node:  b
35.803 : INFO :  addNode 6 b New Stuff 2
35.803 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-23 Rows with only spaces should not interfere
35.803 : TRACE :  Node:  root
35.803 : INFO :  addNode 0 root root 0
35.803 : TRACE :  Stop NL 
35.803 : TRACE :  SPACELINE
35.803 : INFO :  Node:  A
35.803 : INFO :  addNode 1 A A 0
35.803 : INFO :  Node:  B
35.803 : INFO :  addNode 1 B B 0
35.803 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-24 Handle rows above the mindmap declarations
35.804 : TRACE :  SPACELINE
35.804 : TRACE :  Node:  root
35.804 : INFO :  addNode 0 root root 0
35.804 : TRACE :  Stop NL 
35.804 : TRACE :  SPACELINE
35.804 : INFO :  Node:  A
35.804 : INFO :  addNode 1 A A 0
35.804 : INFO :  Node:  B
35.804 : INFO :  addNode 1 B B 0
35.804 : TRACE :  Stop EOF 

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-25 Handle rows above the mindmap declarations, no space
35.804 : TRACE :  SPACELINE
35.804 : TRACE :  Node:  root
35.804 : INFO :  addNode 0 root root 0
35.804 : TRACE :  Stop NL 
35.804 : TRACE :  SPACELINE
35.804 : INFO :  Node:  A
35.804 : INFO :  addNode 1 A A 0
35.804 : INFO :  Node:  B
35.804 : INFO :  addNode 1 B B 0
35.804 : TRACE :  Stop EOF 

 ✓ packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts  (26 tests) 24ms
 ✓ packages/mermaid/src/diagrams/state/parser/state-style.spec.js  (15 tests) 17ms
 ✓ packages/mermaid/src/mermaidAPI.spec.ts  (76 tests) 1229ms
 ✓ packages/mermaid/src/diagrams/state/stateDiagram-v2.spec.js  (29 tests) 18ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-node-data.spec.js  (24 tests) 25ms
 ✓ packages/mermaid/src/diagrams/state/stateDiagram.spec.js  (29 tests | 1 skipped) 15ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/subgraph.spec.js  (22 tests | 1 skipped) 21ms
 ✓ packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js  (27 tests) 30ms
 ✓ packages/mermaid/src/accessibility.spec.ts  (20 tests) 12ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-arrows.spec.js  (14 tests) 18ms
 ✓ packages/mermaid/src/rendering-util/handle-markdown-text.spec.ts  (19 tests) 22ms
 ✓ packages/mermaid/src/rendering-util/rendering-elements/nodes.spec.ts  (39 tests) 4ms
 ✓ packages/mermaid/src/utils/lineWithOffset.ts  (2 tests) 2ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-vertice-chaining.spec.js  (7 tests) 9ms
 ✓ packages/mermaid/src/rendering-util/splitText.spec.ts  (35 tests) 14ms
 ✓ packages/parser/tests/gitGraph.test.ts  (26 tests) 17ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow.spec.js  (25 tests) 35ms
 ✓ packages/mermaid/src/diagrams/git/gitGraphParser.ts  (6 tests) 5ms
 ✓ packages/mermaid/src/diagrams/sequence/svgDraw.spec.js  (6 tests) 7ms
 ✓ packages/parser/tests/pie.test.ts  (31 tests) 15ms
 ✓ packages/mermaid/src/mermaid.spec.ts  (13 tests) 576ms
 ✓ packages/mermaid/src/diagrams/state/parser/state-parser.spec.js  (9 tests) 15ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-interactions.spec.js  (13 tests) 13ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-comments.spec.js  (9 tests) 14ms
 ✓ packages/mermaid/src/diagrams/user-journey/parser/journey.spec.js  (7 tests) 10ms
 ✓ packages/mermaid/src/diagrams/timeline/timeline.spec.js  (7 tests) 8ms
 ✓ packages/mermaid/src/diagram-api/frontmatter.spec.ts  (12 tests) 9ms
 ✓ packages/mermaid/src/diagrams/pie/pie.spec.ts  (14 tests | 2 skipped) 35ms
 ✓ packages/mermaid/src/diagrams/packet/packet.spec.ts  (9 tests) 38ms
 ✓ packages/mermaid/src/diagrams/class/classDiagram-styles.spec.js  (10 tests) 20ms
 ✓ packages/mermaid/src/diagrams/flowchart/flowChartShapes.spec.js  (11 tests) 7ms
 ✓ packages/mermaid/src/styles.spec.ts  (76 tests) 342ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Container.spec.js  (48 tests) 27ms
 ✓ packages/mermaid/src/docs/.vitepress/theme/redirect.spec.ts  (28 tests) 8ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-lines.spec.js  (9 tests) 13ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4System.spec.js  (42 tests) 32ms
 ✓ packages/mermaid/src/diagram.spec.ts  (6 tests) 199ms
 ✓ packages/mermaid/src/diagram-api/diagram-orchestration.spec.ts  (23 tests) 8ms
 ✓ packages/mermaid/src/diagrams/common/common.spec.ts  (20 tests) 22ms
 ✓ packages/mermaid/src/config.spec.ts  (5 tests) 10ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4PersonExt.spec.js  (7 tests) 10ms
 ✓ packages/mermaid/src/rendering-util/rendering-elements/edgeMarker.spec.ts  (5 tests) 5ms
 ✓ packages/mermaid/src/dagre-wrapper/edgeMarker.spec.ts  (5 tests) 3ms
 ✓ packages/mermaid/src/diagrams/user-journey/journeyDb.spec.js  (9 tests) 5ms
 ✓ packages/mermaid/src/diagrams/state/stateDb.spec.js  (5 tests) 10ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Person.spec.js  (7 tests) 8ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Boundary.spec.js  (6 tests) 12ms
 ✓ packages/mermaid/src/diagram-api/comments.spec.ts  (5 tests) 4ms
stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 1 - intersection on left edge of box
39.755 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":31,"y":143.2257070163421}
  insidePoint : {"x":99.3359375,"y":100}
  node        : x:171 y:100 w:210 h:184
39.755 : DEBUG :  sides calc abc89, Q 43.22570701634211, q 22.139152558958802, R 68.3359375, r 35 { _x: 66, _y: 122.1391525589588 }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 2 - intersection on left edge of box
39.756 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":310.2578125,"y":169.88002060631462}
  insidePoint : {"x":127.96875,"y":100}
  node        : x:100.23046875 y:176.75 w:184.4609375 h:337.5
39.756 : DEBUG :  sides calc abc89, Q 69.88002060631462, q 45.15711441743504, R 182.2890625, r 117.796875 { _x: 192.4609375, _y: 145.15711441743503 }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 3 - intersection on top of box outside point greater then inside point
39.757 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":157,"y":39}
  insidePoint : {"x":104,"y":105}
  node        : x:114 y:164 w:212 h:176
39.757 : DEBUG :  abc89 topp/bott calc, Q 66, q 37, R 53, r 29.71212121212121 { x: 133.71212121212122, y: 76 }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 4 - intersection on top of box inside point greater then inside point
39.757 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":144,"y":38}
  insidePoint : {"x":198,"y":105}
  node        : x:114 y:164 w:212 h:176
39.757 : DEBUG :  abc89 topp/bott calc, Q 67, q 38, R 54, r 30.62686567164179 { x: 174.62686567164178, y: 76 }

 ✓ packages/mermaid/src/dagre-wrapper/edges.spec.js  (4 tests) 2ms
 ✓ packages/mermaid/src/diagrams/quadrant-chart/quadrantDb.spec.ts  (4 tests) 3ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-direction.spec.js  (4 tests) 10ms
 ✓ packages/mermaid/src/diagrams/flowchart/flowDb.spec.ts  (7 tests) 3ms
 ✓ packages/mermaid/src/diagrams/flowchart/parser/flow-md-string.spec.js  (2 tests) 7ms
 ✓ packages/mermaid/src/diagram-api/diagramAPI.spec.ts  (3 tests) 25ms
 ✓ packages/mermaid/src/diagrams/c4/parser/c4Diagram.spec.js  (3 tests) 6ms
 ✓ packages/mermaid/src/utils/imperativeState.spec.ts  (3 tests) 1ms
 ❯ packages/mermaid/src/diagrams/sankey/parser/sankey.spec.ts  (0 test)
 ✓ packages/mermaid/src/rendering-util/createText.spec.ts  (4 tests) 5ms
 ✓ packages/mermaid/src/diagrams/info/info.spec.ts  (4 tests) 27ms
 ✓ packages/parser/tests/info.test.ts  (12 tests) 6ms
 ✓ packages/mermaid/src/setupGraphViewbox.spec.js  (2 tests) 2ms
 ✓ packages/mermaid/src/utils/subGraphTitleMargins.spec.ts  (1 test) 2ms
 ✓ packages/mermaid-example-diagram/src/exampleDiagram.spec.js  (1 test) 2ms
 ✓ packages/mermaid/src/diagrams/class/svgDraw.spec.js  (2 tests) 2ms
 ↓ packages/mermaid/src/diagrams/flowchart/parser/flow-huge.spec.js  (1 test | 1 skipped)
 ✓ |@mermaid-js/docs| .vitepress/theme/redirect.spec.ts  (28 tests) 4ms
 ✓ packages/mermaid/src/diagrams/block/layout.spec.ts  (1 test) 1ms
 ✓ packages/mermaid/src/diagrams/class/parser/class.spec.js  (2 tests) 6ms
 ✓ packages/mermaid/src/diagrams/er/erRenderer.spec.ts  (1 test) 1ms

 Test Files  2 failed | 86 passed | 1 skipped (89)
      Tests  3262 passed | 10 skipped | 2 todo (3274)
   Start at  11:35:28
   Duration  8.29s (transform 4.47s, setup 880ms, collect 17.39s, tests 4.70s, environment 20.41s, prepare 5.45s)

 ELIFECYCLE  Command failed with exit code 1.
